<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
 <head> 
  <title>Post-Quantum Lattice-Based Cryptography Implementations: A Survey</title> 
  <!-- Copyright (c) 2010-2015 The MathJax Consortium -->
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /> 
  <meta name="viewport" content="width=device-width; initial-scale=1.0;" /> 
  <meta http-equiv="X-UA-Compatible" content="IE=edge" /> 
  <link media="screen, print" rel="stylesheet" href="https://dl.acm.org/pubs/lib/css/bootstrap.min.css" /> 
  <link media="screen, print" rel="stylesheet" href="https://dl.acm.org/pubs/lib/css/bootstrap-theme.min.css" /> 
  <link media="screen, print" rel="stylesheet" href="https://dl.acm.org/pubs/lib/css/main.css" /> 
  <script src="https://dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script> 
  <script src="https://dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script> 
  <script src="https://dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script> 
  <script src="https://dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script> 
  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script> 
  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script> 
 </head> 
 <body> 
  <section class="front-matter"> 
   <section> 
    <header class="title-info"> 
     <div class="journal-title"> 
      <h1> <span class="title">Post-Quantum Lattice-Based Cryptography Implementations: A Survey</span> <span class="shortTitle">Post-Quantum Lattice-Based Cryptography Implementations: A Survey</span> </h1> 
     </div> 
    </header> 
    <div class="authorGroup"> 
     <div class="author" style="display:inline;"> 
      <span class="givenName">HAMID</span> 
      <span class="surName">NEJATOLLAHI</span> 
      <strong> and </strong> 
      <a class="aff" href="#aff1"></a> 
     </div> 
     <div class="author" style="display:inline;"> 
      <span class="givenName">NIKIL</span> 
      <span class="surName">DUTT</span>, 
      <a class="aff" href="#aff1"></a> 
      <aff id="aff1">
       University of California Irvine
      </aff> 
     </div> 
    </div> 
    <div class="authorGroup"> 
     <div class="author" style="display:inline;"> 
      <span class="givenName">SANDIP</span> 
      <span class="surName">RAY</span>, 
      <a class="aff" href="#aff2"></a> 
      <aff id="aff2">
       University of Florida
      </aff> 
     </div> 
    </div> 
    <div class="authorGroup"> 
     <div class="author" style="display:inline;"> 
      <span class="givenName">FRANCESCO</span> 
      <span class="surName">REGAZZONI</span>, 
      <a class="aff" href="#aff3"></a> 
      <aff id="aff3">
       ALaRi
      </aff> 
     </div> 
    </div> 
    <div class="authorGroup"> 
     <div class="author" style="display:inline;"> 
      <span class="givenName">INDRANIL</span> 
      <span class="surName">BANERJEE</span> 
      <strong> and </strong> 
      <a class="aff" href="#aff4"></a> 
     </div> 
     <div class="author" style="display:inline;"> 
      <span class="givenName">ROSARIO</span> 
      <span class="surName">CAMMAROTA</span>, 
      <a class="aff" href="#aff4"></a> 
      <aff id="aff4">
       Qualcomm Technologies Inc.
      </aff> 
     </div> 
    </div> 
    <br /> 
    <div class="pubInfo"> 
     <p> <small>ACM Comput. Surv., Vol. 51, No. 6, Article 129, Publication date: January 2019.<br />DOI: <a href="https://doi.org/10.1145/3292548">https://doi.org/10.1145/3292548</a> </small> </p> 
    </div> 
    <div class="abstract"> 
     <p> <small>The advent of quantum computing threatens to break many classical cryptographic schemes, leading to innovations in public key cryptography that focus on post-quantum cryptography primitives and protocols resistant to quantum computing threats. Lattice-based cryptography is a promising post-quantum cryptography family, both in terms of foundational properties as well as in its application to both traditional and emerging security problems such as encryption, digital signature, key exchange, and homomorphic encryption. While such techniques provide guarantees, in theory, their realization on contemporary computing platforms requires careful design choices and tradeoffs to manage both the diversity of computing platforms (e.g., high-performance to resource constrained), as well as the agility for deployment in the face of emerging and changing standards. In this work, we survey trends in lattice-based cryptographic schemes, some recent fundamental proposals for the use of lattices in computer security, challenges for their implementation in software and hardware, and emerging needs for their adoption. The survey means to be informative about the math to allow the reader to focus on the mechanics of the computation ultimately needed for mapping schemes on existing hardware or synthesizing part or all of a scheme on special-purpose har dware.</small> </p> 
    </div> 
    <div class="classifications" style="font-size:16px;"> 
     <div class="categories"> 
      <span class="CRCat"> <span class="CRCatHd"> <small> <strong>CCS Concepts:</strong> </small></span> <span class="CRCatNbr"><small><strong>• Security and privacy → </strong><strong>Public key (asymmetric) techniques</strong>; <em>Hardware-based security protocols</em>; </small></span></span> 
     </div> 
     <br /> 
     <div class="categories"> 
      <span class="CRCat"> <span class="CRCatHd"> <small> <strong>Additional Key Words and Phrases:</strong> </small></span> <span class="CRCatNbr"> <small>Post-quantum cryptography</small></span>, <span class="CRCatNbr"> <small>public-key encryption</small></span>, <span class="CRCatNbr"> <small>lattice based cryptography</small></span>, <span class="CRCatNbr"> <small>ideal lattices</small></span>, <span class="CRCatNbr"> <small>Ring-LWE</small></span></span> 
     </div> 
     <br /> 
     <div class="AcmReferenceFormat"> 
      <p> <small> <span style="font-weight:bold;">ACM Reference format:</span> <br />Hamid Nejatollahi, Nikil Dutt, Sandip Ray, Francesco Regazzoni, Indranil Banerjee, and Rosario Cammarota. 2019. Post-Quantum Lattice-Based Cryptography Implementations: A Survey. <em>ACM Comput. Surv.</em> 51, 6, Article 129 (January 2019), 41 pages. <a class="link-inline force-break" href="https://doi.org/10.1145/3292548">https://doi.org/10.1145/3292548</a> </small> </p> 
     </div> 
    </div> 
   </section> 
  </section> 
  <section class="body"> 
   <section id="sec-5"> 
    <header> 
     <div class="title-info"> 
      <h2> <span class="section-number">1</span> INTRODUCTION</h2> 
     </div> 
    </header> 
    <p>Advances in computing efficiency steadily erode computer security at its foundation, and this enables prospective attackers to use ever more powerful computing systems and the best cryptanalysis algorithms to increase attack speed. One aspect of this arises from Moore's Law, that predicts that traditional computing systems will become more powerful than ever before, allowing increasingly larger brute-force attacks. Another aspect of concern is the rise of alternative computing paradigms, such as quantum computing and its algorithms [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0002">2</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0003">3</a>], that seem to be closer than ever to reality,<a class="fn" data-trigger="hover" data-toggle="popover" data-placement="top" href="#fn18" id="foot-fn18"><sup>1,</sup></a> <a class="fn" data-trigger="hover" data-toggle="popover" data-placement="top" href="#fn19" id="foot-fn19"><sup>2</sup></a> which in turn promises to further weaken the strength of current, standardized cryptography and its applications. Against quantum computers, traditional public key cryptography is ineffective for any key length algorithm. Shor's algorithm for quantum computers is designed to solve prime factorization of large primes and the discrete logarithm problem in polynomial time.</p> 
    <p>The emergence of new computing platforms, such as cloud computing, software-defined networks, and the Internet of Everything, demands the adoption of an increasing number of security standards, which in turn requires the implementation of a diverse set of cryptographic primitives—but this is only part of the story. At the computing platform level, we are seeing a diversity of computing capabilities ranging from high-performance (real-time) virtualized environments, such as cloud computing resources and software-defined networks, to highly resource-constrained Internet of Things (IoT) platforms to realize the vision of the Internet of Everything. This poses tremendous challenges in the design and implementation of emerging standards for cryptography in a single embodiment since the computing platforms exact diverging goals and constraints. On one end of the spectrum, in the cloud computing and software-defined network space, applications demand high performance and energy efficiency from cryptographic implementations. This calls for the development of programmable hardware capable of efficiently running not only individual cryptographic algorithms, but full protocols, with the resulting challenge of designing for agility (e.g., designing computing engines that achieve the efficiency of Application-Specific Integrated Circuits (ASICs) while retaining some level of programmability). On the other end of the spectrum, in the IoT space, implementations of standardized cryptography to handle increased key sizes become too expensive in terms of cost, speed, and energy, but are necessary (e.g., in the case of long-lived systems such as medical implants and image encryption algorithms [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0004">4</a>]). In part, this demands the development of new and strong, lightweight alternatives to symmetric key cryptography as well [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0005">5</a>]. Furthermore, given the variety of applications and their interplay with the cloud, even in this case, agility in the implementation becomes a key requirement.</p> 
    <p>As a result of the trends in technology, the need to strengthen current practices in computer security, including strengthening and adding more variety in the cryptographic primitives in use, has become a widely accepted fact. The preceding examples, to name a few, form a compelling argument for innovation in the computer security space, including and beyond the foundations, down to the actual implementation and deployment of primitives and protocols to satisfy emerging business models and their design constraints: latency, compactness, energy efficiency, tamper resistance, and, more importantly, agility.</p> 
    <p>Innovation in public key cryptography focuses on the standardization of the so-called post-quantum cryptography primitives and their protocols. Among the post-quantum cryptography families, the family of Lattice-Based Cryptography (<span style="font-family:monospace">LBC</span>) appears to be gaining acceptance. Its applications are proliferating for both traditional security problems (e.g., key exchange and digital signature), as well as emerging security problems (e.g., homomorphic schemes, identity-based encryption, and even symmetric encryption). Lattice-based cryptographic primitives and protocols provides a rich set of primitives which can be used to tackle the challenges posed by deployment across diverse computing platforms (e.g., cloud vs. IoT ecosystems) as well as for diverse use cases, including the ability to perform computation on encrypted data by providing strong (much better understood than before) foundations for protocols based on asymmetric key cryptography against powerful attackers (using quantum computers and algorithms) and to offer protection beyond the span of traditional cryptography. Indeed, LBC promises to enhance security for long-lived systems (e.g., critical infrastructures), as well as for safety-critical devices such as smart medical implants [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0006">6</a>].</p> 
    <p>In this article, we review the foundations of LBC, some of the more adopted instances of lattices in security, their implementations in software and hardware, and their applications to authentication, key exchange, and digital signatures. The purpose of this survey is to focus on the essential ideas and mechanics of the cryptosystems based on lattices and the corresponding implementation aspects. We believe that this survey is not only unique, but also important for guidance in the selection of standards, as well as in the analysis and evaluation of candidate implementations that represent state of the art.</p> 
    <p>The remainder of the article is organized as follows. In Section <a class="sec" href="#sec-6">2</a>, we provide the relevant background to make the article self-contained. We briefly describe different lattice constructions and <span style="font-family:monospace">LBC</span> in Section <a class="sec" href="#sec-28">2.5</a>. Section <a class="sec" href="#sec-33">3</a> discusses various implementations of lattice-based schemes. Section <a class="sec" href="#sec-34">3.1</a> discusses related art on improvements for arithmetic computation (i.e., polynomial/matrix multiplication or/and noise sampler). Sections <a class="sec" href="#sec-41">3.2</a> and <a class="sec" href="#sec-45">3.3</a> present software and hardware implementations of different <span style="font-family:monospace">LBC</span>. Sections <a class="sec" href="#sec-51">4</a> concludes with an outlook.</p> 
   </section> 
   <section id="sec-6"> 
    <header> 
     <div class="title-info"> 
      <h2> <span class="section-number">2</span> BACKGROUND</h2> 
     </div> 
    </header> 
    <section id="sec-7"> 
     <header> 
      <div class="title-info"> 
       <h3> <span class="section-number">2.1</span> Standard Lattices</h3> 
      </div> 
     </header> 
     <p>Lattice <span class="inline-equation"><span class="tex">$\mathcal {L}$</span></span> is the infinite set (discrete) of points in <span class="inline-equation"><span class="tex">$n$</span></span>-dimensional Euclidean space with a periodic structure [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0007">7</a>]. A basis (<span class="inline-equation"><span class="tex">$B$</span></span>) of the lattice is defined as <span class="inline-equation"><span class="tex">${\bf b}_1$</span></span>, <span class="inline-equation"><span class="tex">${\bf b}_2,\ldots,{\bf b}_n$</span></span> <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/2bcd2ef9-19bf-47c0-b867-dc401d780f21/csur5106-129-inline6.gif" class="img-responsive" alt="" longdesc="" /></span> to be <span class="inline-equation"><span class="tex">$n$</span></span>-linearly independent vectors in <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/f84a6d7d-74f1-4b09-9e78-72c0eccec20b/csur5106-129-inline8.gif" class="img-responsive" alt="" longdesc="" /></span>. <span class="inline-equation"><span class="tex">$B$</span></span> is a <span class="inline-equation"><span class="tex">$d \times n$</span></span> matrix in which <span class="inline-equation"><span class="tex">$ith^{}$</span></span> column is <span class="inline-equation"><span class="tex">${\bf b}_i$</span></span> vector such that <span class="inline-equation"><span class="tex">$B=[{\bf b}_1, {\bf b}_2,\ldots, {\bf b}_n]$</span></span>. Integer <span class="inline-equation"><span class="tex">$n$</span></span> and <span class="inline-equation"><span class="tex">$d$</span></span> are rank and dimension of the lattice <span class="inline-equation"><span class="tex">$\mathcal {L}(B)$</span></span>. If <span class="inline-equation"><span class="tex">$n=d$</span></span>, <span class="inline-equation"><span class="tex">$\mathcal {L}(B)$</span></span> is a full rank (or dimension) lattice in <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/2b9f17af-c8bb-4071-82e6-92c0c156c19f/csur5106-129-inline19.gif" class="img-responsive" alt="" longdesc="" /></span>. All integer combinations generated by the basis matrix <span class="inline-equation"><span class="tex">$B$</span></span> (with integer or rational entries) form the lattice <span class="inline-equation"><span class="tex">$\mathcal {L}$</span></span>: </p>
     <div class="display-equation" id="eq1"> 
      <span class="tex mytex"> <img src="https://dl.acm.org/cms/attachment/364adeb1-f465-40aa-be7a-ddc553adf57b/csur5106-129-eqn1.gif" class="img-responsive" alt="" longdesc="" /></span> 
      <span class="equation-number"> <label>(1)</label></span> 
     </div> 
     <p></p> 
    </section> 
    <section id="sec-8"> 
     <header> 
      <div class="title-info"> 
       <h3> <span class="section-number">2.2</span> Ideal Lattices</h3> 
      </div> 
     </header> 
     <p>An ideal lattice is defined over a ring <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/3ba0824f-0367-47f5-bbfb-ee383b1875c1/csur5106-129-inline22.gif" class="img-responsive" alt="" longdesc="" /></span>, where <span class="inline-equation"><span class="tex">$f(x)=x^n + f_nx^{n-1} +\cdots +f_1 \in Z[x]$</span></span> (cyclotomic polynomial) and <span class="inline-equation"><span class="tex">$R$</span></span> contains all the polynomials with modulo <span class="inline-equation"><span class="tex">$q$</span></span> integer coefficients. In the case where <span class="inline-equation"><span class="tex">$f(x)$</span></span> is monic (leading coefficient is 1) irreducible polynomial degree-n, <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/fb14f268-d3f9-4884-9ad2-b9b16d2d0609/csur5106-129-inline27.gif" class="img-responsive" alt="" longdesc="" /></span> includes polynomials of degree less than or equal to <span class="inline-equation"><span class="tex">$n-1$</span></span>. For instance, <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/1d661f05-6459-47d3-b30d-3b3f576bea41/csur5106-129-inline29.gif" class="img-responsive" alt="" longdesc="" /></span> is an ideal lattice when <span class="inline-equation"><span class="tex">$n$</span></span> is a power of 2; however, <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/8902c63e-7bee-4177-8ce0-fe9048a88a51/csur5106-129-inline31.gif" class="img-responsive" alt="" longdesc="" /></span> is not an ideal lattice since <span class="inline-equation"><span class="tex">$(x^n-1)$</span></span> is a reducible polynomial.</p> 
    </section> 
    <section id="sec-9"> 
     <header> 
      <div class="title-info"> 
       <h3> <span class="section-number">2.3</span> Lattice Problems and Their Applications to Cryptography</h3> 
      </div> 
     </header> 
     <p>The breakthrough work of Ajtai [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0008">8</a>] provides confidence for adopting lattice-based schemes in cryptography. Ajtai proves that solving some <span style="font-family:monospace">NP-hard</span> lattice problems (e.g., Shortest Vector Problem [SVP]) in the average case is as hard as solving the worst-case assumption. In order to solve the <span style="font-family:monospace">SVP</span> problem, one should solve the problem for any input basis <span class="inline-equation"><span class="tex">$B$</span></span> (all instances of the <span style="font-family:monospace">SVP</span> problem should be solved). It is conjectured that there is no probabilistic polynomial time algorithm that can approximate certain computational problems on lattices to within polynomial factors [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0009">9</a>]. This is the basis for the security of LBC schemes. The fastest algorithm to solve the <span style="font-family:monospace">SVP</span> problem has the time and memory complexity of 2<span class="inline-equation"><span class="tex">$^{O(n)}$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0010">10</a>--<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0012">12</a>]. We take the following definitions from Aggarwal et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0013">13</a>].</p> 
     <section id="sec-10"> 
      <p> <span class="section-number">2.3.1</span> <em>Shortest Vector Problem (SVP).</em> There are three variants of the <span style="font-family:monospace">SVP</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0013">13</a>] that can be reduced to each other. The first is to find the shortest nonzero vector, the second is to find the length of the shortest nonzero vector, and the third determines if the shortest nonzero vector is shorter than a given real number. Given <span class="inline-equation"><span class="tex">$B$</span></span> as the lattice basis, <span class="inline-equation"><span class="tex">$v \in \mathcal {L}(B)\backslash \lbrace 0\rbrace \rbrace$</span></span> is defined as the shortest nonzero vector in lattice <span class="inline-equation"><span class="tex">$\mathcal {L}(B)$</span></span> such that <span class="inline-equation"><span class="tex">$\Vert v\Vert =\lambda _1(\mathcal {L}(B))$</span></span>. Output of the SVP problem is <strong>a</strong>, the shortest nonzero vector in the lattice which is unique. <span style="font-family:monospace">SVP</span> can be defined to an arbitrary norm (we use norm 2 here as the Euclidean norm). In <span class="inline-equation"><span class="tex">$\gamma$</span></span>-Approximate SVP (<span class="inline-equation"><span class="tex">$SVP_\gamma$</span></span>), for <span class="inline-equation"><span class="tex">$\gamma \ge 1$</span></span>, the goal is to find the shortest nonzero vector <span class="inline-equation"><span class="tex">$v \in \mathcal {L}(B)\backslash \lbrace 0\rbrace$</span></span> where <span class="inline-equation"><span class="tex">$\Vert v\Vert \le \lambda _1(\mathcal {L}(B))$</span></span>. The special case of <span class="inline-equation"><span class="tex">$\gamma =1$</span></span> is equivalent to the exact <span style="font-family:monospace">SVP</span>. The decision variant of the SVP (<span class="inline-equation"><span class="tex">$G_{AP}SVP_{\gamma }$</span></span>) is defined as determining if <span class="inline-equation"><span class="tex">$d \lt \lambda _1(\mathcal {L}(B)) \le \gamma.d$</span></span> where <span class="inline-equation"><span class="tex">$d$</span></span> is a positive real number.</p> 
     </section> 
     <section id="sec-11"> 
      <p> <span class="section-number">2.3.2</span> <em>Closest Vector Problem (CVP).</em> Let <span class="inline-equation"><span class="tex">$B$</span></span> and <span class="inline-equation"><span class="tex">$t$</span></span> be the lattice basis and the target point (might not be a member of the lattice), respectively; CVP is defined as finding vector <span class="inline-equation"><span class="tex">$v \in \mathcal {L}$</span></span> where its distance (<span class="inline-equation"><span class="tex">$\Vert v-t\Vert$</span></span>) to a target point is minimized [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0013">13</a>]. In <span class="inline-equation"><span class="tex">$\gamma$</span></span>-Approximate CVP (<span class="inline-equation"><span class="tex">$CVP_\gamma$</span></span>), for <span class="inline-equation"><span class="tex">$\gamma \ge 1$</span></span>, the goal is to find vector <span class="inline-equation"><span class="tex">$v \in \mathcal {L}(B)$</span></span> such that <span class="inline-equation"><span class="tex">$\Vert v-t\Vert \le \gamma .dist(t,\mathcal {L}(B))$</span></span> where <span class="inline-equation"><span class="tex">$dist(t,\mathcal {L(B)})=inf\lbrace \Vert v-t\Vert :v\in \mathcal {L}\rbrace$</span></span> is the distance of target point <span class="inline-equation"><span class="tex">$t$</span></span> to the lattice <span class="inline-equation"><span class="tex">$\mathcal {L}$</span></span>.</p> 
     </section> 
     <section id="sec-12"> 
      <p> <span class="section-number">2.3.3</span> <em>Shortest Independent Vectors Problem (SIVP).</em> Given lattice basis <span class="inline-equation"><span class="tex">$B$</span></span> and prime integer <span class="inline-equation"><span class="tex">$q$</span></span>, the (SIVP) is defined as finding <span class="inline-equation"><span class="tex">$n$</span></span> linearly independent lattice vectors <span class="inline-equation"><span class="tex">$\lbrace v=v_1,\ldots,v_n : v_i \in \mathcal {L}(B) for 1 \le i \le n\rbrace$</span></span> that minimize <span class="inline-equation"><span class="tex">$\Vert v\Vert$</span></span> = max<span class="inline-equation"><span class="tex">$_i\Vert v_i\Vert$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0013">13</a>]. Given an approximate factor <span class="inline-equation"><span class="tex">$\gamma \ge 1$</span></span>, the <span class="inline-equation"><span class="tex">$\gamma -approximate$</span></span> (<span class="inline-equation"><span class="tex">$SIVP_\gamma$</span></span>) is defined as finding <span class="inline-equation"><span class="tex">$n$</span></span>-linearly independent vectors lattice vectors <span class="inline-equation"><span class="tex">$\lbrace v=v_1,\ldots,v_n : v_i \in \mathcal {L}(B)$</span></span> such that max<span class="inline-equation"><span class="tex">$_i\Vert v_i\Vert \le \lambda _n(\mathcal {L}(B)$</span></span> where <span class="inline-equation"><span class="tex">$\lambda _n$</span></span> denotes the <span class="inline-equation"><span class="tex">$nth^{}$</span></span> success minima. For an <span class="inline-equation"><span class="tex">$n$</span></span>-dimensional lattice, <span class="inline-equation"><span class="tex">$\lambda _i$</span></span>, <span class="inline-equation"><span class="tex">$ith^{}$</span></span> success minima is the radius of the smallest ball that contains <span class="inline-equation"><span class="tex">$i$</span></span> linearly independent lattice vectors. The decision version of SIVP is called (<span class="inline-equation"><span class="tex">$G_{AP}SIVP_{\gamma }$</span></span>) and is defined as determined if <span class="inline-equation"><span class="tex">$d \lt \lambda _n(\mathcal {L}(B)) \le \gamma .d$</span></span> where <span class="inline-equation"><span class="tex">$d$</span></span> is a positive real number.</p> 
      <p>There is a close relationship between hard lattice problems (e.g., CVP and SVP) and average-case lattice-based problems, Learning with Error (<span style="font-family:monospace">LWE</span>) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0007">7</a>], and Shortest Integer Solution (<span style="font-family:monospace">SIS</span>) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0008">8</a>].</p> 
     </section> 
     <section id="sec-13"> 
      <p> <span class="section-number">2.3.4</span> <em>Shortest Integer Solution (SIS).</em> Let <span class="inline-equation"><span class="tex">$a_1$</span></span>, <span class="inline-equation"><span class="tex">$a_2,\ldots,a_n$</span></span> <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/c536baf2-c5ab-4529-ad9f-cb7f9dac9275/csur5106-129-inline83.gif" class="img-responsive" alt="" longdesc="" /></span> be an arbitrary vector and <span class="inline-equation"><span class="tex">$q$</span></span> is an integer prime number. The SIS problem is defined as finding the vector <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/2c7d00d9-e4d9-4d1c-9e2d-9c6dbcbee3b6/csur5106-129-inline85.gif" class="img-responsive" alt="" longdesc="" /></span> such that <span class="inline-equation"><span class="tex">$x_1.a_1+x_2.a_2 + \cdots + x_n.a_n=0 \text { (mod } q)$</span></span>. Short usually translates as <span class="inline-equation"><span class="tex">$z_i \in \lbrace -1,0,+1\rbrace$</span></span>. Considering q-ary lattices, let <span class="inline-equation"><span class="tex">$A$</span></span> = (<span class="inline-equation"><span class="tex">$a_1$</span></span>, <span class="inline-equation"><span class="tex">$a_2,\ldots,a_n$</span></span>) be a vector in <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/26155f6c-1139-44b0-a7e7-bddea21bd359/csur5106-129-inline91.gif" class="img-responsive" alt="" longdesc="" /></span> and <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/997a7c9c-b129-4726-8afd-d0129881beb5/csur5106-129-inline92.gif" class="img-responsive" alt="" longdesc="" /></span> (mod <span class="inline-equation"><span class="tex">$q$</span></span>); the SIS problem is to find the shortest vector problem for the lattice <span class="inline-equation"><span class="tex">$\Lambda _q^{\bot }$</span></span>. Based on Ajtai's theorem, if polynomial time algorithm <span class="inline-equation"><span class="tex">$A$</span></span> solves the SIS problem, an efficient algorithm <span class="inline-equation"><span class="tex">$B$</span></span> exists that can solve the SVP (or SVIP) problem for any lattice of dimension <span class="inline-equation"><span class="tex">$n$</span></span> in polynomial time.</p> 
     </section> 
     <section id="sec-14"> 
      <p> <em>Ring-SIS.</em> Let <span class="inline-equation"><span class="tex">$A$</span></span> = (<span class="inline-equation"><span class="tex">$a_1$</span></span>, <span class="inline-equation"><span class="tex">$a_2,\ldots,a_n$</span></span>) be a vector with <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/d3a9a0d5-08d6-4efc-8622-ea959ac56466/csur5106-129-inline101.gif" class="img-responsive" alt="" longdesc="" /></span> and <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/7dad0a12-f6bc-476d-a0ea-faafda5c2fa7/csur5106-129-inline102.gif" class="img-responsive" alt="" longdesc="" /></span> (mod <span class="inline-equation"><span class="tex">$q$</span></span>); the Ring-SIS problem is to find the shortest vector problem for the lattice <span class="inline-equation"><span class="tex">$\Lambda _q^{\bot }$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0014">14</a>].</p> 
     </section> 
     <section id="sec-15"> 
      <p> <span class="section-number">2.3.5</span> <em>Learning with Error (LWE).</em> Let <span class="inline-equation"><span class="tex">$a$</span></span> be the polynomial with coefficients sampled uniformly at random in <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/38a864c9-fccc-4475-b196-22a0c4222f5a/csur5106-129-inline106.gif" class="img-responsive" alt="" longdesc="" /></span>, where <span class="inline-equation"><span class="tex">$n$</span></span> and <span class="inline-equation"><span class="tex">$q$</span></span> are degrees of lattice and modulus (prime integer), respectively. Recovering the (<span class="inline-equation"><span class="tex">${\bf unique}$</span></span>) random secret <span class="inline-equation"><span class="tex">$s$</span></span> (uniformly at random in <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/ab2886c3-2f68-4e7f-ae7a-066f5135c3f6/csur5106-129-inline111.gif" class="img-responsive" alt="" longdesc="" /></span>) from <span class="inline-equation"><span class="tex">$m$</span></span> (<span class="inline-equation"><span class="tex">$m \ge n$</span></span>) samples of the form <span class="inline-equation"><span class="tex">$(a,a.s+e \text { mod } q)$</span></span> is known as the <span style="font-family:monospace">LWE</span>) problem where <span class="inline-equation"><span class="tex">$e$</span></span> is the error that is sampled from error distribution <span class="inline-equation"><span class="tex">$\chi$</span></span>. The worst-case hardness assumption of the LWE problem is proved under the quantum [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0007">7</a>] and classical [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0015">15</a>] reductions. In addition, if secret <span class="inline-equation"><span class="tex">$s$</span></span> is sampled from the same error distribution as <span class="inline-equation"><span class="tex">$e$</span></span>, the hardness assumption of the LWE problem is still valid [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0016">16</a>].</p> 
     </section> 
     <section id="sec-16"> 
      <p> <em>Ring-LWE.</em> Let <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/4382af3c-d6c5-4e01-b0f7-e947c6f1a4bd/csur5106-129-inline119.gif" class="img-responsive" alt="" longdesc="" /></span> be the ring of polynomials where <span class="inline-equation"><span class="tex">$n$</span></span> is power of 2 and <span class="inline-equation"><span class="tex">$q$</span></span> is an integer. Recovering random secret <span class="inline-equation"><span class="tex">$s$</span></span> with uniform coefficients in <span class="inline-equation"><span class="tex">$R$</span></span> from <span class="inline-equation"><span class="tex">$m \ge 1$</span></span> samples <span class="inline-equation"><span class="tex">$(a_i,a_i.s+e_i \text { mod } q)$</span></span> is known as the Ring-LWE problem, where <span class="inline-equation"><span class="tex">$e \in R$</span></span> is the error with coefficients sampled from error distribution <span class="inline-equation"><span class="tex">$\chi$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0017">17</a>].</p> 
     </section> 
     <section id="sec-17"> 
      <p> <em>Learning with Rounding (LWR).</em> The complexity and inefficiency of the decisional (<span style="font-family:monospace">LWE</span>) problem prohibit its use for PRGs. The LWR problem [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0018">18</a>] is the “derandomized” variant of the <span style="font-family:monospace">LWE</span> with improved speedup (by eliminating sampling small errors from a Gaussian-like distribution with deterministic errors) and bandwidth (by rounding <span class="inline-equation"><span class="tex">$Z_q$</span></span> to the sparse subset <span class="inline-equation"><span class="tex">$R_p$</span></span>). <span style="font-family:monospace">LWE</span> hides the lower order bits by adding a small error; however, <span style="font-family:monospace">LWR</span> conceals the lower order bits with rounding. Let <span class="inline-equation"><span class="tex">$a_i$</span></span> be sampled uniformly at random in <span class="inline-equation"><span class="tex">$Z^n_q$</span></span> and <span class="inline-equation"><span class="tex">$\lfloor \cdot \rceil :Z_q \rightarrow Z_p$</span></span> for <span class="inline-equation"><span class="tex">$p \lt q$</span></span> be the modular “rounding function” where <span class="inline-equation"><span class="tex">$\lfloor x \rceil _p = \lfloor (p/q) \cdot x \rceil$</span></span>mod <span class="inline-equation"><span class="tex">$p$</span></span>. Similar to <span style="font-family:monospace">LWE</span>, <span style="font-family:monospace">LWR</span> is defined as recovering the (<span class="inline-equation"><span class="tex">${\bf unique}$</span></span>) secret <span class="inline-equation"><span class="tex">$s$</span></span> (uniformly at random in <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/39456f45-fdac-4ba8-b013-05ef8a60ccfb/csur5106-129-inline138.gif" class="img-responsive" alt="" longdesc="" /></span>) from <span class="inline-equation"><span class="tex">$m \ge 1$</span></span> samples <span class="inline-equation"><span class="tex">$(a_i , \lfloor \langle a_i,s \rangle \rceil _p) \in Z^n_q \times Z_p$</span></span>. In other words, there is no probabilistic polynomial time algorithm that can distinguish pairs of <span class="inline-equation"><span class="tex">$(a_i \leftarrow Z_q, \lfloor \langle a_i,s \rangle \rceil _p) \in Z^n_q \times Z_p$</span></span> with <span class="inline-equation"><span class="tex">$(a_i \leftarrow Z_q, \lfloor u \rceil _p)$</span></span> where <span class="inline-equation"><span class="tex">$u$</span></span> is uniformly random in <span class="inline-equation"><span class="tex">$Z_q$</span></span>. <span style="font-family:monospace">LWR</span> is assumed to be hard under the hardness assumption of <span style="font-family:monospace">LWE</span> when the number of samples is bounded.</p> 
     </section> 
     <section id="sec-18"> 
      <p> <em>Module-LWE.</em> Let <span class="inline-equation"><span class="tex">$n$</span></span> and <span class="inline-equation"><span class="tex">$d$</span></span> be dimensions of <span class="inline-equation"><span class="tex">$R$</span></span> (degree of ring <span class="inline-equation"><span class="tex">$R_q$</span></span>) and rank of module <span class="inline-equation"><span class="tex">$M \in R^d$</span></span>. The hardness of a scheme with <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/ffcafedc-5125-4c9e-842b-349d91ffa792/csur5106-129-inline150.gif" class="img-responsive" alt="" longdesc="" /></span> and <span class="inline-equation"><span class="tex">$d=1$</span></span> is based on Ring-LWE and Ring-SIS problems; however <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/cde293f4-f894-4c6e-b7bb-00a0f1af69a9/csur5106-129-inline152.gif" class="img-responsive" alt="" longdesc="" /></span> and <span class="inline-equation"><span class="tex">$d\gt 1$</span></span> end up with LWE and SIS problems. Module-LWE/SIS is a generalization of LWE/SIS and Ring-LWE/SIS in which the parameters are <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/50a6333d-1820-49e1-a54f-ce74affd80fd/csur5106-129-inline154.gif" class="img-responsive" alt="" longdesc="" /></span> and <span class="inline-equation"><span class="tex">$d\ge 1$</span></span>. Security reduction of lattice problems in module <span class="inline-equation"><span class="tex">$M$</span></span> depends on <span class="inline-equation"><span class="tex">$N=n \times d$</span></span> (dimension of the corresponding module lattice) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0019">19</a>]. Suppose <span class="inline-equation"><span class="tex">$A$</span></span> is a <span class="inline-equation"><span class="tex">$d \times d$</span></span> random matrix; security reduction of the LWE/SIS problem for <span class="inline-equation"><span class="tex">$d=1$</span></span> (Ring-SIS/LWE) and ring of dimension <span class="inline-equation"><span class="tex">$n$</span></span> is the same as <span class="inline-equation"><span class="tex">$d=i$</span></span> and a ring of dimension <span class="inline-equation"><span class="tex">$n/i$</span></span>. In the former case, matrix <span class="inline-equation"><span class="tex">$A$</span></span> contains <span class="inline-equation"><span class="tex">$n$</span></span> elements in <span class="inline-equation"><span class="tex">$Z_q$</span></span>; however, in the latter case, <span class="inline-equation"><span class="tex">$A$</span></span> contains <span class="inline-equation"><span class="tex">$i^2 \times n$</span></span> elements in <span class="inline-equation"><span class="tex">$Z_q$</span></span>.</p> 
      <p>Let <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/9185b2ae-7ac5-49fa-9f5b-a2f048123496/csur5106-129-inline170.gif" class="img-responsive" alt="" longdesc="" /></span> and <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/20f7c217-6d3c-4069-88c0-c65632cab90d/csur5106-129-inline171.gif" class="img-responsive" alt="" longdesc="" /></span> be the ring of polynomials where <span class="inline-equation"><span class="tex">$n$</span></span> is a power of 2 and <span class="inline-equation"><span class="tex">$q \in Z$</span></span>. Vector <span class="inline-equation"><span class="tex">$a$</span></span> is uniformly sampled in <span class="inline-equation"><span class="tex">$R_q^d$</span></span>. Recovering the random secret <span class="inline-equation"><span class="tex">$s$</span></span> with coefficients sampled from the error distribution <span class="inline-equation"><span class="tex">$\chi ^d$</span></span> in <span class="inline-equation"><span class="tex">$R$</span></span> from <span class="inline-equation"><span class="tex">$m \ge 1$</span></span> samples <span class="inline-equation"><span class="tex">$(a_i,a_i.s+e_i \text { mod } q) \leftarrow R_q^d \times R_q$</span></span> is known as the Module LWE problem, where <span class="inline-equation"><span class="tex">$e_i \in R$</span></span> is the error with coefficients sampled from error distribution <span class="inline-equation"><span class="tex">$\chi$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0019">19</a>].</p> 
      <p> <span style="font-family:monospace">Module-LWE</span>/<span style="font-family:monospace">Module-LWR</span> is a middle ground problem for <span style="font-family:monospace">LWE</span>/<span style="font-family:monospace">LWR</span> and their ring variant <span style="font-family:monospace">RLWE</span>/<span style="font-family:monospace">RLWR</span> which reduces computational pressure and bandwidth of the standard lattices and improves the security of the ideal lattices. With the same arithmetic foundation, <em>Module-LWE</em>/<em>Module-LWR</em> provides a tradeoff between security and cost (computation and bandwidth).</p> 
     </section> 
    </section> 
    <section id="sec-19"> 
     <header> 
      <div class="title-info"> 
       <h3> <span class="section-number">2.4</span> Arithmetic and Components of Lattices</h3> 
      </div> 
     </header> 
     <p>In this section, we provide an evaluation of the components in an <span style="font-family:monospace">LBC</span> that guide the actual implementation. Two components are critical: <span class="inline-equation"><span class="tex">$(a)$</span></span> the polynomial multiplication for ideal lattices and matrix multiplication for standard lattice as the main speedup bottlenecks and <span class="inline-equation"><span class="tex">$(b)$</span></span> the discrete Gaussian sampling to sample noise in order to hide the secret information. There are various algorithms for the sampler and multiplier in the literature that provide the designer with a specific goal [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0020">20</a>]. We briefly review different algorithms and outline their practical implementations in Section <a class="sec" href="#sec-34">3.1</a> </p> 
     <p>Two main classes of lattice-based algorithms used in cryptography are <span style="font-family:monospace">NTRU</span> and <span style="font-family:monospace">LWE</span>. The security of <span style="font-family:monospace">NTRU</span> is based on hardness not-provably reducible to solving the <span style="font-family:monospace">CVP</span> in a lattice, whereas the security of <span style="font-family:monospace">LWE</span> relies on provably reducible solving the <span style="font-family:monospace">SVP</span>) in a lattice. Consequently, <span style="font-family:monospace">NTRU</span> suffers from security guarantees but in practice provides more flexibility and efficiency in the implementation. On the contrary, <span style="font-family:monospace">LWE</span> problems are resistant to quantum attacks, while their relatively inefficient nature led researchers to devise more efficient formulations (e.g., over rings, as in <span style="font-family:monospace">Ring-LWE</span>).</p> 
     <p>Implementations are broadly classified into pure software, pure hardware, and hardware/software co-design cryptographic engines [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0020">20</a>]. Implementation of modulo arithmetic (multiplication and addition of big numbers) is a bottleneck in <span style="font-family:monospace">LBC</span>. For standard <span style="font-family:monospace">LWE</span> schemes, matrix multiplication algorithms are adopted, whereas Number Theoretic Transform (<span style="font-family:monospace">NTT</span>) is a better choice for polynomial multiplication in <span style="font-family:monospace">Ring-LWE</span>. A summary of modular arithmetic is presented in Figure <a class="fig" href="#fig1">1</a>.</p> 
     <figure id="fig1"> 
      <img src="https://dl.acm.org/cms/attachment/e9c974cb-7d23-4891-b8e0-0d5c996395bc/csur5106-129-f01.jpg" class="img-responsive" alt="Fig. 1." longdesc="" /> 
      <div class="figure-caption"> 
       <span class="figure-number">Fig. 1.</span> 
       <span class="figure-title">Common modular multiplication algorithms.</span> 
      </div> 
     </figure> 
     <p>The other bottleneck in <span style="font-family:monospace">LBC</span> is the extraction of the random/noise term, which usually is implemented with a discrete noise sampler from a discrete Gaussian distribution and can be done with rejection, inversion, Ziggurat, or Knuth-Yao sampling.</p> 
     <p>Implementation of standard <span style="font-family:monospace">LWE-based</span> schemes exhibits a large memory footprint due to the large key size—hundreds of kilobytes for the public key—which renders a straightforward implementation of standard LWE-based schemes impractical. The adoption of specific ring structures (e.g., <span style="font-family:monospace">Ring-LWE</span>) offers key size reduction by a factor of <em>n</em> compared to standard <span style="font-family:monospace">LWE</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0017">17</a>], making <span style="font-family:monospace">Ring-LWE</span> an excellent candidate for resource-constrained devices such as Wi-Fi-capable smart devices, including medical implants. Another avenue to address resource-constrained devices is that the memory footprint can be traded-off with security assurance, which improves both efficiency and memory consumption.</p> 
     <p>Practical software implementations of standard lattices, encryption schemes [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0031">31</a>], and key exchanges [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0032">32</a>], have been published. For hardware implementations, FPGAs provide flexibility and customization but not agility. Hardware implementations of lattice-based schemes (e.g., BLISS-I [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0033">33</a>] with higher security level) are about an order of magnitude faster than the hardware implementation of RSA-2048 [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0034">34</a>]. Another candidate platform to implement <span style="font-family:monospace">LBC</span> is Application-Specific Integrated Circuits (ASICs) of which there appear to be no such implementations in the literature at this time. However, the main advantages and challenges for the ASIC design of <span style="font-family:monospace">LBC</span> are presented in Oder et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0035">35</a>].</p> 
     <section id="sec-20"> 
      <p> <span class="section-number">2.4.1</span> <em>The Multiplier Component.</em> Matrix multiplication is used for standard lattices, while polynomial multiplication is employed for ideal lattices. Arithmetic operations for a <span style="font-family:monospace">Ring-LWE</span> -based scheme are performed over a ring of polynomials. The most time- and memory-consuming part is polynomial multiplication. The easiest way to multiply two polynomials is to use the Schoolbook algorithm with the time complexity of <span class="inline-equation"><span class="tex">$O(n^2)$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0021">21</a>]. Let <span class="inline-equation"><span class="tex">$n$</span></span>, power of two, and <span class="inline-equation"><span class="tex">$p$</span></span> be degree of the lattice and a prime number (<span class="inline-equation"><span class="tex">$p$</span></span> = 1 mod 2<span class="inline-equation"><span class="tex">$n$</span></span>), respectively. <span class="inline-equation"><span class="tex">$Z_p$</span></span> denotes the ring of integers modulo <span class="inline-equation"><span class="tex">$p$</span></span> and <span class="inline-equation"><span class="tex">$x^{n+1}$</span></span> is an irreducible degree <span class="inline-equation"><span class="tex">$n$</span></span> polynomial. The quotient ring <span class="inline-equation"><span class="tex">$R_p$</span></span> contains all polynomials with the degree less than <span class="inline-equation"><span class="tex">$n$</span></span> in <span class="inline-equation"><span class="tex">$Z_p$</span></span>, that is defined as <span class="inline-equation"><span class="tex">$R_p$</span></span> = <span class="inline-equation"><span class="tex">$Z_p$</span></span>/[<span class="inline-equation"><span class="tex">$x^{n+1}$</span></span>] in which coefficients of polynomials are in [0,<span class="inline-equation"><span class="tex">$p$</span></span>).</p> 
      <p>The <span style="font-family:monospace">NTT</span> is a generalization of Fast Fourier Transform (<span style="font-family:monospace">FFT</span>), which is carried out in a finite field instead of complex numbers. The latter could achieve time complexity of <span class="inline-equation"><span class="tex">$O$</span></span>(<span class="inline-equation"><span class="tex">$n$</span></span>log<span class="inline-equation"><span class="tex">$n$</span></span>). In other words, exp(-2<span class="inline-equation"><span class="tex">$\pi$</span></span>j/N) with <span class="inline-equation"><span class="tex">$nth^{}$</span></span> primitive root of unity <span class="inline-equation"><span class="tex">$\omega _n$</span></span> which is defined as the smallest element in the ring that <span class="inline-equation"><span class="tex">$\omega _n^n$</span></span> = 1 mod <span class="inline-equation"><span class="tex">$p$</span></span> and <span class="inline-equation"><span class="tex">${\omega _{{\rm n}}}^i$</span></span> <span class="inline-equation"><span class="tex">$\ne$</span></span> 1 mod <em>p</em> for i <span class="inline-equation"><span class="tex">$\ne$</span></span> n. The main idea behind this is to use the point value representation instead of the coefficient representation by applying NTT in <span class="inline-equation"><span class="tex">$O$</span></span>(<span class="inline-equation"><span class="tex">$n$</span></span>log<span class="inline-equation"><span class="tex">$n$</span></span>), thereafter performing point-wise multiplication in <span class="inline-equation"><span class="tex">$O(n)$</span></span> and finally converting the result to coefficient representation by applying Inverse NTT (<span style="font-family:monospace">INTT</span>) in <span class="inline-equation"><span class="tex">$O$</span></span>(<span class="inline-equation"><span class="tex">$n$</span></span>log<span class="inline-equation"><span class="tex">$n$</span></span>). </p>
      <div class="table-responsive"> 
       <div class="display-equation" id="eq2"> 
        <span class="tex mytex">\begin{equation} a(x)\times b(x) = NTT^{-1}(NTT(a)\odot NTT(b)) , \end{equation}</span> 
        <span class="equation-number"> <label>(2)</label></span> 
       </div> 
      </div> where 
      <span class="inline-equation"><span class="tex">$\odot$</span></span> is the point-wise multiplication of the coefficients. If NTT is applied to 
      <span class="inline-equation"><span class="tex">$a(x)$</span></span> with 
      <span class="inline-equation"><span class="tex">$({a}_{0},\ldots,{a}_{n-1})$</span></span> as coefficients, we would have 
      <span class="inline-equation"><span class="tex">$(\hat{a_{0}},\ldots,\hat{a_{n-1}}) = NTT(a_{0},\ldots,a_{n-1})$</span></span> where 
      <div class="table-responsive"> 
       <div class="display-equation" id="eq3"> 
        <span class="tex mytex">\begin{equation} \hat{a_{i}} = \sum _{j=0}^{n-1} a_{i}\omega ^{ij} mod (p) , i=0,1,\ldots,n-1. \end{equation}</span> 
        <span class="equation-number"> <label>(3)</label></span> 
       </div> 
      </div> 
      <p></p> 
      <p>To retrieve the answer from the point value representation using <span class="inline-equation"><span class="tex">$NTT^{-1}$</span></span>, it is sufficient to apply the NTT function with <span class="inline-equation"><span class="tex">$-\omega$</span></span> and divide all the coefficients by <span class="inline-equation"><span class="tex">$n$</span></span>: </p>
      <div class="table-responsive"> 
       <div class="display-equation" id="eq4"> 
        <span class="tex mytex">\begin{equation} {a_{i}} = \sum _{j=0}^{n-1} \hat{a}_{i}\omega ^{-ij} mod (p) , i=0,1,\ldots,n-1. \end{equation}</span> 
        <span class="equation-number"> <label>(4)</label></span> 
       </div> 
      </div> In order to compute NTT(
      <span class="inline-equation"><span class="tex">$a$</span></span>), we pad the vector of coefficients with 
      <span class="inline-equation"><span class="tex">$n$</span></span> zeros, which leads to doubling the input size. The negative wrapped convolution technique [
      <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0036">36</a>], avoids doubling the input size.
      <p></p> 
      <p>To improve the efficiency of polynomial multiplications with <span style="font-family:monospace">NTT</span>, combining multiplications of powers of <span class="inline-equation"><span class="tex">$\omega$</span></span> with powers of <span class="inline-equation"><span class="tex">$\psi$</span></span> and <span class="inline-equation"><span class="tex">${\psi }^{-1}$</span></span> (<span class="inline-equation"><span class="tex">${\psi }^{2} = \omega$</span></span>) is beneficial, but requires storage memory for precomputed powers of <span class="inline-equation"><span class="tex">$\omega$</span></span> and <span class="inline-equation"><span class="tex">${\psi }^{-1}$</span></span> in bit-reversed order [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0037">37</a>--<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0039">39</a>]. NTT can be used only for the <span class="inline-equation"><span class="tex">$p$</span></span> = 1 (mod 2 <span class="inline-equation"><span class="tex">$n$</span></span>) case where p is a prime integer. Suppose <span class="inline-equation"><span class="tex">$a^{\prime }$</span></span> = <span class="inline-equation"><span class="tex">$(a_{0},\psi a_{1}, \ldots,\psi ^{n-1}a_{n-1})$</span></span>, <span class="inline-equation"><span class="tex">$b^{\prime }$</span></span> = <span class="inline-equation"><span class="tex">$(b_{0},\psi b_{1}, \ldots,\psi ^{n-1}b_{n-1})$</span></span>, <span class="inline-equation"><span class="tex">$c^{\prime }$</span></span> = <span class="inline-equation"><span class="tex">$(c_{0},\psi c_{1}, \ldots,\psi ^{n-1}c_{n-1})$</span></span> to be coefficient vectors of the <span class="inline-equation"><span class="tex">$a$</span></span>, <span class="inline-equation"><span class="tex">$b$</span></span>, <span class="inline-equation"><span class="tex">$c$</span></span> that are multiplied component-wise by <span class="inline-equation"><span class="tex">$(1,\psi ^{1}, \ldots,\psi ^{n-1})$</span></span>. Based on the negative wrapped convolution theorem, modulo <span class="inline-equation"><span class="tex">$(x^n+1)$</span></span> is eliminated and the degree of NTT and <span class="inline-equation"><span class="tex">$NTT^{-1}$</span></span> is reduced from 2<span class="inline-equation"><span class="tex">$n$</span></span> to <span class="inline-equation"><span class="tex">$n$</span></span>: </p>
      <div class="table-responsive"> 
       <div class="display-equation" id="eq5"> 
        <span class="tex mytex">\begin{equation} c^{\prime } = NTT^{-1}(NTT(a^{\prime })\odot NTT(b^{\prime })), \end{equation}</span> 
        <span class="equation-number"> <label>(5)</label></span> 
       </div> 
      </div> 
      <div class="table-responsive"> 
       <div class="display-equation" id="eq6"> 
        <span class="tex mytex">\begin{equation} c = (\psi ^{0}{c^{\prime }}_{0},\psi ^{-1}{c^{\prime }}_{1}, \ldots,\psi ^{-n+1}{c^{\prime }}_{n-1}). \end{equation}</span> 
        <span class="equation-number"> <label>(6)</label></span> 
       </div> 
      </div> 
      <p></p> 
      <p>Two common algorithms to compute NTT are the Cooley-Tukey (CT) butterfly [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0027">27</a>] and Gentleman-Sande (GS) butterfly [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0028">28</a>]. <span style="font-family:monospace">CT</span>, decimation-in-time, outputs the result in the bit-reverse order by getting the input in the correct order. <span style="font-family:monospace">GS</span>, decimation-in-frequency, receives the input in the reverse order and produces the output in the correct order [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0039">39</a>]. Employing <span style="font-family:monospace">GS</span> to compute both NTT and <span class="inline-equation"><span class="tex">$NTT^{-1}$</span></span> involves bit-reverse calculation [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>]; however, the bit-reverse step can be avoided by using <span style="font-family:monospace">CT</span> for NTT and <span style="font-family:monospace">GS</span> for <span class="inline-equation"><span class="tex">$NTT^{-1}$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0039">39</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0041">41</a>].</p> 
      <p>Other popular multiplication algorithms in the literature are the Karatsuba algorithm (with time complexity of <span class="inline-equation"><span class="tex">$O(n^{log3/log2})$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0023">23</a>]) and subsequent variants of it [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0042">42</a>]. Sch&ouml;nhage-Strassen with time complexity of <span class="inline-equation"><span class="tex">$O$</span></span>(<span class="inline-equation"><span class="tex">$n$</span></span>.log<span class="inline-equation"><span class="tex">$n$</span></span>.loglog<span class="inline-equation"><span class="tex">$n$</span></span>) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0024">24</a>] outperforms the Karatsuba algorithm [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0043">43</a>].</p> 
      <p>An extensive analysis and comparison for hardware complexity of various modular multiplications, including Schoolbook (classical), Karatsuba, and FFT with different operand sizes, are presented in David et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0042">42</a>], in which the authors calculate the hardware complexity of each multiplier by decomposing it into smaller units such as the full adder, half adder, multiplexer, and gate. Rafferty et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0044">44</a>] adopt the same approach to analyze large integer multiplications of both combined and individual multipliers. The Karatsuba multiplier outperforms for operands greater than or equal to 32 bits. Schoolbook imposes a large memory footprint in order to store partial products, which negatively impact performance; this is mitigated by Comba [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0045">45</a>] with the same time complexity but relaxing memory addressing by optimizing the sequence of partial products. Rafferty et al. compare hardware complexity, in terms of <span class="inline-equation"><span class="tex">$+$</span></span>, <span class="inline-equation"><span class="tex">$-$</span></span>, and <span class="inline-equation"><span class="tex">$*$</span></span> units of different combinations of classical (Comba), Karatsuba, and FFT (NTT for integers) for up to multipliers with 65536-bit operands. However, they evaluate the latency and clock frequency by implementing in hardware (Xilinx Virtex-7 FPGA) for up to 256 bits for the combination of NTT+Comba and 4096-bit for Karatsuba+Comba, which are not in a good range for LBC (e.g., <span class="inline-equation"><span class="tex">$1024 \times 14 = 14336$</span></span> bits are used for NewHope key exchange). Based on their (analytical) hardware complexity analysis, the combination of Karatsuba-Schoolbook is the best choice for operands under 64 bits. Karatsuba-Comba is preferable for operands of from 64 to 256 bits. For larger operands, the lowest hardware complexity is achieved by combined multiplier NTT-Karatsuba-Schoolbook.</p> 
     </section> 
     <section id="sec-21"> 
      <p> <span class="section-number">2.4.2</span> <em>The Sampler Component.</em> The quality of a discrete Gaussian sampler is determined by a tuple of three parameters: <span class="inline-equation"><span class="tex">$\sigma$</span></span>, <span class="inline-equation"><span class="tex">$\lambda$</span></span>, <span class="inline-equation"><span class="tex">$\tau$</span></span>. In such a tuple, <span class="inline-equation"><span class="tex">$\sigma$</span></span> is the standard deviation (adjusts dispersal of data from the mean), <span class="inline-equation"><span class="tex">$\lambda$</span></span> is the precision parameter (controls statistical difference between a perfect and implemented discrete Gaussian sampler), and <span class="inline-equation"><span class="tex">$\tau$</span></span> is the distribution tail-cut (determines amount of the distribution that we would like to ignore). Each of these parameters affects the security and efficiency of the sampler. For instance, a smaller standard deviation decreases the memory footprint required to store precomputed tables. For encryption/decryption schemes, <span class="inline-equation"><span class="tex">$\sigma =3.33$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0046">46</a>] is suggested. Digital signature sampling from a Gaussian sampler involves a large <span class="inline-equation"><span class="tex">$\sigma$</span></span> = 215 [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0033">33</a>]. However, by employing Peikert's convolution lemma [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0047">47</a>], the standard deviation can be reduced by an order of magnitude, which is a remarkable improvement on the precomputed table size. Speed and memory footprint are <span class="inline-equation"><span class="tex">$\lambda$</span></span> dependent (i.e., higher <span class="inline-equation"><span class="tex">$\lambda$</span></span> results in more secure but a slower and bigger sampler). The tail of the Gaussian distribution touches the x-axis at x = +<span class="inline-equation"><span class="tex">$\infty$</span></span> (considering only the positive side due to symmetry) with negligible probability. Tail-cut parameter (<span class="inline-equation"><span class="tex">$\tau$</span></span>) defines the amount of the distribution that we would like to ignore; hence, random number <span class="inline-equation"><span class="tex">$e$</span></span> is sampled in <span class="inline-equation"><span class="tex">$|e| \in \lbrace 0,\sigma \times \tau \rbrace$</span></span> instead <span class="inline-equation"><span class="tex">$|e| \in \lbrace 0,\infty \rbrace$</span></span>. Instead of the statistical distance, the R&eacute;nyi divergence technique [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0048">48</a>] can be employed to measure the distance between two probability distributions (e.g., [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>]). More precisely, in LBC, R&eacute;nyi divergence is used to generalized security reductions. Sampling the discrete Gaussian distribution is one the most time- and memory-hungry parts of lattice-based cryptosystems due to the demands of high precision, many random bits, and huge lookup tables. To be more specific, the obligatory negligible statistical distance between the implementation of a Gaussian sampler (approximated) and the theoretical (perfect) discrete Gaussian distribution imposes expensive precise floating point arithmetic (to calculate the exponential function) or a large memory footprint (to store precomputed probabilities). To keep statistical distance less than <span class="inline-equation"><span class="tex">$2^{- \lambda }$</span></span>, floating point precision with more than standard double-precision is obligatory, which is not natively supported by the underlying platform; thus software libraries should be used to perform higher floating-point arithmetic. It is impractical to sample from a perfect Gaussian sampler; hence, a <span class="inline-equation"><span class="tex">$\lambda$</span></span>-bit uniform random integer is used to approximate the discrete sampler. Fortunately, it is proved that the Gaussian sampler could be used to achieve a <span class="inline-equation"><span class="tex">$ \lambda$</span></span>/2 security level (approximated sampler) instead of a <span class="inline-equation"><span class="tex">$\lambda$</span></span> level (perfect sampler) since (to date) there is no algorithm that can distinguish between a perfect sampler (<span class="inline-equation"><span class="tex">$\lambda$</span></span> bits) and an approximate sampler (<span class="inline-equation"><span class="tex">$\lambda$</span></span>/2 bits) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0049">49</a>]. In other words, we can cut half of the bits in the sampler, which results in a smaller and faster sampler [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0031">31</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0050">50</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0051">51</a>]. Reduction in the precision parameter (from <span class="inline-equation"><span class="tex">$\lambda$</span></span> to <span class="inline-equation"><span class="tex">$\lambda$</span></span>/2) changes tail-cut parameter (<span class="inline-equation"><span class="tex">$\tau$</span></span>) as <span class="inline-equation"><span class="tex">$\tau = \sqrt {\lambda \times 2.ln(2)}$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0052">52</a>]. Sampling from a Gaussian distribution may lead to a timing side-channel attack, which can be avoided by using a constant generic time Gaussian sampling over integers [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0053">53</a>]. Foll&aacute;th provides a survey of different Gaussian samplers in LBC schemes with a more mathematical outlook [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0054">54</a>]. Gaussian samples are classified into six categories, and guidelines are provided for choosing the best candidate on different platforms for specific parameter ranges. However, we organize Gaussian samplers into the types discussed later. A summary of advantage and disadvantages of each sampler is given in Table <a class="table" href="#tab1">1</a>.</p> 
      <div id="tab1" class="table-responsive"> 
       <div class="table-caption"> 
        <span class="table-number">Table 1.</span> 
        <span class="table-title">Comparison of Different Gaussian Samplers; Partially Extracted from Ducas et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0033">33</a>]</span> 
       </div> 
       <table class="table"> 
        <thead> 
         <tr> 
          <th align="left" style="border-bottom:1px solid black"> <strong>Sampler</strong> </th> 
          <th align="center" style="border-bottom:1px solid black"> <strong>Speed</strong> </th> 
          <th align="center" style="border-bottom:1px solid black"> <strong>FP exp()</strong> </th> 
          <th align="center" style="border-bottom:1px solid black"> <strong>Table Size</strong> </th> 
          <th align="center" style="border-bottom:1px solid black"> <strong>Table Lookup</strong> </th> 
          <th align="center" style="border-bottom:1px solid black"> <strong>Entropy</strong> </th> 
          <th align="center" style="border-bottom:1px solid black"> <strong>Features</strong> </th> 
         </tr> 
        </thead> 
        <tbody> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Rejection</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">slow</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">10</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">0</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">0</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">45+10<span class="inline-equation"><span class="tex">$log_2 \sigma$</span></span> </td> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Suitable for constrained devices</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Ziggurat</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">flexible</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">flexible</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">flexible</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">flexible</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">flexible</td> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Suitable for encryption requires high-precision FP arithmetic; not suitable for HW implementation</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">CDT</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">fast</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">0</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <span class="inline-equation"><span class="tex">$\sigma \tau \lambda$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <span class="inline-equation"><span class="tex">$log_2(\tau \sigma)$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">2.1+<span class="inline-equation"><span class="tex">$log_2 \sigma$</span></span> </td> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Suitable for digital signature easy to implement</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Knuth-Yao</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">fastest</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">0</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1/2<span class="inline-equation"><span class="tex">$\sigma \tau \lambda$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <span class="inline-equation"><span class="tex">$log_2(\sqrt {2 \pi e} \sigma)$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">2.1+<span class="inline-equation"><span class="tex">$log_2 \sigma$</span></span> </td> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Not suitable for digital signature</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Bernoulli</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">fast</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">0</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <span class="inline-equation"><span class="tex">$\lambda log_2(2.4\tau \sigma ^2)$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <span class="inline-equation"><span class="tex">$\approx log_2 \sigma$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <span class="inline-equation"><span class="tex">$\approx 6+3log_2 \sigma$</span></span> </td> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Suitable for all schemes</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Binomial</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">fast</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">0</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">0</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">0</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <span class="inline-equation"><span class="tex">$4\sigma ^2$</span></span> </td> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Not suitable for digital signature</td> 
         </tr> 
        </tbody> 
       </table> 
      </div> 
     </section> 
     <section id="sec-22"> 
      <p> <em> <strong>Rejection Sampler</strong>.</em> First, <span class="inline-equation"><span class="tex">$x$</span></span> is sampled in (-<span class="inline-equation"><span class="tex">$\tau \sigma ,\tau \sigma$</span></span>), uniformly at random, where <span class="inline-equation"><span class="tex">$\tau$</span></span> and <span class="inline-equation"><span class="tex">$\sigma$</span></span> are the tail-cut and standard deviation of Gaussian distribution. After that, <span class="inline-equation"><span class="tex">$x$</span></span> is rejected with the probability proportional to 1-exp(-<span class="inline-equation"><span class="tex">$x^2/2\sigma ^2$</span></span>). The high rejection rate of samples (on average eight trials to reach acceptance) along with the expensive calculation of <span style="font-family:monospace">exp()</span> are the main reasons for inefficiency [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0055">55</a>]. G&ouml;ttert et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0056">56</a>] employ a rejection sampler for the first time within <span style="font-family:monospace">LBC</span>. Remarkable speed and area improvement could be achieved by performing the rejection operation using lazy floating-point arithmetic [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0057">57</a>].</p> 
     </section> 
     <section id="sec-23"> 
      <p> <em> <strong>Bernoulli Sampler</strong>.</em> Bernoulli is an optimized version of rejection sampling that reduces the average number of required attempts for a successful sampler from 10 to around 1.47 with no need to calculate the <span style="font-family:monospace">exp()</span> function or precomputed tables [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0058">58</a>]. Bernoulli is introduced in Ducas et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0033">33</a>] for LBC and used widely in the research community [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0031">31</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0059">59</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0060">60</a>]. The main idea behind Bernoulli sampling is to approximate sampling from <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/91a32bdc-a17a-4e21-ba61-d75b6b329c0c/csur5106-129-inline303.gif" class="img-responsive" alt="" longdesc="" /></span> using the distribution <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/58cf7298-1c25-4af6-a7b3-0182ff8199e7/csur5106-129-inline304.gif" class="img-responsive" alt="" longdesc="" /></span> where <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/7b7f1578-8a66-4d5c-88eb-b8f25241f6b5/csur5106-129-inline305.gif" class="img-responsive" alt="" longdesc="" /></span> is the uniform distribution. The procedure for a Bernoulli sampler is shown here in five steps.</p> 
      <ol class="list-no-style"> 
       <li label="(1)"> Sample <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/7dbfa822-366a-4c3b-a058-43daf38e2e8f/csur5106-129-inline306.gif" class="img-responsive" alt="" longdesc="" /></span> according to <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/8bc10633-eab1-4177-9e2e-6b31a1d7af5f/csur5106-129-inline307.gif" class="img-responsive" alt="" longdesc="" /></span> with probability density of <span class="inline-equation"><span class="tex">$ \rho _{\sigma _2}=e^{-x^2/(2\sigma _{2}^2)}$</span></span> <br /> </li> 
       <li label="(2)"> Sample <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/42d41126-a521-4729-9ba2-eab349e4baea/csur5106-129-inline309.gif" class="img-responsive" alt="" longdesc="" /></span> uniformly at random in <span class="inline-equation"><span class="tex">$\lbrace 0,\ldots,k-1\rbrace$</span></span> and calculate <span class="inline-equation"><span class="tex">$z \leftarrow y+kx$</span></span>, <span class="inline-equation"><span class="tex">$j \leftarrow y(y+2kx).$</span></span> <br /> </li> 
       <li label="(3)"> Sample <span class="inline-equation"><span class="tex">$b \leftarrow \mathcal {B}_{-j/{2\sigma ^2}}$</span></span> where <span class="inline-equation"><span class="tex">$\sigma =k\sigma _2$</span></span> and <span class="inline-equation"><span class="tex">$\mathcal {B}$</span></span> is the Bernoulli distribution. To sample from <span class="inline-equation"><span class="tex">$\mathcal {B}_{c}$</span></span> where <span class="inline-equation"><span class="tex">$c$</span></span> is a precomputed constant value, a uniform number <span class="inline-equation"><span class="tex">$u \in [0, 1)$</span></span> with <span class="inline-equation"><span class="tex">$\lambda$</span></span>-bit precision is sampled; 1 is returned if <span class="inline-equation"><span class="tex">$u\lt c$</span></span>; otherwise, 0 should be returned.<br /> </li> 
       <li label="(4)"> If <span class="inline-equation"><span class="tex">$b=0$</span></span> goto to step (1).<br /> </li> 
       <li label="(5)"> If <span class="inline-equation"><span class="tex">$z=0$</span></span> go to step (1); otherwise, generate <span class="inline-equation"><span class="tex">$b \leftarrow \mathcal {B}_{1/2}$</span></span> and return <span class="inline-equation"><span class="tex">$(-1)^bz$</span></span> as the output.<br /> </li> 
      </ol> 
      <p>The standard deviation of the target Gaussian sampler <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/06e29b4f-b3b6-4401-b2a9-a8abf0912469/csur5106-129-inline325.gif" class="img-responsive" alt="" longdesc="" /></span> equals <span class="inline-equation"><span class="tex">$k\sigma _2,$</span></span> where <span class="inline-equation"><span class="tex">$\sigma _2=\sqrt {\frac{1}{2ln2}}\approx 0.849$</span></span> and where <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/306ffd91-b9f6-4bab-88aa-59f3480f4887/csur5106-129-inline328.gif" class="img-responsive" alt="" longdesc="" /></span> and <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/a5dacb78-3062-4c26-aaa9-1dded51a6150/csur5106-129-inline329.gif" class="img-responsive" alt="" longdesc="" /></span> are uniform distribution parameters. For schemes with small standard deviation (e.g., public key encryption), sampling from binary Gaussian distribution can be eliminated [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0059">59</a>], whereas for digital signatures with large standard deviation, using Gaussian distribution is mandatory [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0060">60</a>]. Gaussian distribution can be replaced with other distributions (e.g., uniform distribution [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0061">61</a>]). The Bernoulli approach avoids long integer calculation and employs single-bit operations that make it beneficial for hardware implementation. The time dependency of Bernoulli makes it vulnerable to timing attacks that are resolved in the hardware implementation of BLISS [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0060">60</a>]. Precomputed tables in Bernoulli sampling are small; binary Gaussian distribution (easy to sample intermediate sampler) is independent of <span class="inline-equation"><span class="tex">$\sigma ;$</span></span> hence, the Peikert convolution lemma (smaller <span class="inline-equation"><span class="tex">$\sigma$</span></span>) does not have a considerable impact on the area. However, the convolution lemma reduces the area of precomputed tables in the CDT sampler by a factor of <span class="inline-equation"><span class="tex">$23\times$</span></span> for <span style="font-family:monospace">BLISS</span> (reduces <span class="inline-equation"><span class="tex">$\sigma$</span></span> from 215 to 19.47).</p> 
     </section> 
     <section id="sec-24"> 
      <p> <em> <strong>Binomial Sampler</strong>.</em> Centered binomial distribution (<span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/3403b2dc-a216-4c0c-9bf3-c2ddbe9dda18/csur5106-129-inline334.gif" class="img-responsive" alt="" longdesc="" /></span>) is a close approximation of the rounded Gaussian sampler (<span class="inline-equation"><span class="tex">$\xi _\sigma$</span></span>) that eliminates the need for computing <span class="inline-equation"><span class="tex">$exp()$</span></span> and precomputed large tables. Let <span class="inline-equation"><span class="tex">$\sigma =\sqrt {8}$</span></span> be the standard deviation of <span class="inline-equation"><span class="tex">$\xi _\sigma$</span></span> and a binomial distribution is parameterized with <span class="inline-equation"><span class="tex">$k=2\sigma ^2$</span></span>; choosing <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/b190472c-8c8f-4eab-98db-f9c1f5a47fc2/csur5106-129-inline340.gif" class="img-responsive" alt="" longdesc="" /></span> as the sampling distribution has negligible statistical difference with a rounded Gaussian sampler with <span class="inline-equation"><span class="tex">$\sigma =\sqrt {8}$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>]. Centered binomial distribution(<span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/30ab51bd-b868-4435-8648-df106f8fdb39/csur5106-129-inline342.gif" class="img-responsive" alt="" longdesc="" /></span>) for integer <span class="inline-equation"><span class="tex">$k \ge 0$</span></span> is defined as sampling <span class="inline-equation"><span class="tex">$2 \cdot k$</span></span> random numbers uniformly from <span class="inline-equation"><span class="tex">$\lbrace 0,1\rbrace$</span></span> as <span class="inline-equation"><span class="tex">$(a_1,\ldots,a_k,b1,\ldots,b_k)$</span></span> and outputting <span class="inline-equation"><span class="tex">$\sum _{i=1}^{k} (a_i,b_i)$</span></span> as the random sample [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>]. Since <span class="inline-equation"><span class="tex">$k$</span></span> scales with power 2 of <span class="inline-equation"><span class="tex">$\sigma$</span></span>, it is not practical to use binomial sampling for digital signatures with large standard deviation. A binomial sampler has been employed inside software implementations of NewHope [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0062">62</a>--<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0065">65</a>], HILA5 [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0066">66</a>], LAC [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0067">67</a>], LIMA [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0068">68</a>], Kyber [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0041">41</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0069">69</a>], and Titanium [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0070">70</a>]. It also is used in the hardware implementation of NewHope [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0071">71</a>].</p> 
     </section> 
     <section id="sec-25"> 
      <p> <em> <strong>Ziggurat Sampler</strong>.</em> The Ziggurat sampler is a variation of the rejection sampler introduced in Marsaglia et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0072">72</a>] for a continuous Gaussian sampler.<a class="fn" data-trigger="hover" data-toggle="popover" data-placement="top" href="#fn20" id="foot-fn20"><sup>3</sup></a> A discrete version of Ziggurat sampler is proposed in Buchmann et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0076">76</a>], which is suitable for schemes with large standard deviation. The area under the probability density function is divided into <span class="inline-equation"><span class="tex">$n$</span></span> rectangles with the same area whose size is proportional to the probability of sampling a point in each rectangle. The left and right corners of each rectangle are on the <span class="inline-equation"><span class="tex">$y$</span></span>-axis and Gaussian distribution curve, respectively. Each rectangle is stored using its lower right coordinates (Figure <a class="fig" href="#fig2">2</a>). First, rectangle <span class="inline-equation"><span class="tex">$R_i$</span></span> and point <span class="inline-equation"><span class="tex">$x_i$</span></span> inside the rectangle is chosen uniformly at random. Since we are considering positive <span class="inline-equation"><span class="tex">$x_i$</span></span>, a random sign bit, <span class="inline-equation"><span class="tex">$s$</span></span>, is also required. If <span class="inline-equation"><span class="tex">$x_i \le x_{i-1}$</span></span>, <span class="inline-equation"><span class="tex">$x_i$</span></span> resides below the curve and would be accepted. Otherwise, a uniformly random <span class="inline-equation"><span class="tex">$y_i$</span></span> is sampled, and, if <span class="inline-equation"><span class="tex">$y_i \le exp(x_i)$</span></span>, the random point <span class="inline-equation"><span class="tex">$(x_i,y_i)$</span></span> is accepted; otherwise, a new random <span class="inline-equation"><span class="tex">$x$</span></span> should be sampled and the process is repeated.</p> 
      <figure id="fig2"> 
       <img src="https://dl.acm.org/cms/attachment/66f66f53-d15c-486a-8c10-4fe357dd94db/csur5106-129-f02.jpg" class="img-responsive" alt="Fig. 2." longdesc="" /> 
       <div class="figure-caption"> 
        <span class="figure-number">Fig. 2.</span> 
        <span class="figure-title">A partition of Ziggurat [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0076">76</a>].</span> 
       </div> 
      </figure> 
      <p>More rectangles lead to a reduction in the number of rejections, better performance, and higher precision. Due to its flexibility, Ziggurat offers a tradeoff between memory consumption and performance, making it suitable for resource-constrained embedded devices. More precision and performance require more precomputed rectangles that impose heavy memory overhead, and the increase in the number of precomputed rectangles could drop performance if the cache is fully occupied. Consequently, the software implementation is preferred to any hardware implementation. There is only one hardware implementation of Ziggurat in the literature which hints at the impracticality of realizing the Ziggurat sampler in hardware [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0052">52</a>].</p> 
     </section> 
     <section id="sec-26"> 
      <p> <em> <strong>Cumulative Distribution Table (CDT) Sampling</strong>.</em> CDT is also known as the inversion sampling method [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0047">47</a>]. CDT is faster than rejection and Ziggurat samplers by avoiding the use of expensive floating-point arithmetic [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0077">77</a>]. Since in cumulative distribution all the numbers are less than 1, it is sufficient to use the binary expansion of the fraction. CDT requires a large table to store values of the Cumulative Distribution Function (CDF) of the discrete Gaussian (highest memory footprint [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0054">54</a>]) for which their size is a function of distribution the tail-cut (<span class="inline-equation"><span class="tex">$\tau$</span></span>) and Gaussian parameter (<span class="inline-equation"><span class="tex">$\sigma$</span></span>). Variable <span class="inline-equation"><span class="tex">$r$</span></span> is sampled uniformly at random in the range [0,1) with <span class="inline-equation"><span class="tex">$\lambda$</span></span> bits of precision. The goal is to find an <span class="inline-equation"><span class="tex">$x$</span></span> whose probability is <span class="inline-equation"><span class="tex">$\rho (x)=S[x+1]-S[x],$</span></span> where <span class="inline-equation"><span class="tex">$S[x]$</span></span> equals the value of CDF at <span class="inline-equation"><span class="tex">$x$</span></span>. CDT performs a search, usually a binary search, on the CDF to find the corresponding <span class="inline-equation"><span class="tex">$x$</span></span>. A standard CDT needs a table of size at least <span class="inline-equation"><span class="tex">$\sigma \tau \lambda$</span></span> bits; for instance, <span style="font-family:monospace">BLISS-IV</span> (<span class="inline-equation"><span class="tex">$\sigma =13.4, \tau =215, \lambda =128$</span></span>) and <span style="font-family:monospace">BLISS-I</span> (<span class="inline-equation"><span class="tex">$\sigma =13.4, \tau =19.54, \lambda =128$</span></span>) need at least precomputed tables of size 630 kbits and 370 kbits for 192- and 128-bit post-quantum security, respectively, which is not practical for resource-constrained embedded devices [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0033">33</a>]. By employing Peikert's convolution lemma [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0047">47</a>], the size of precomputed tables is dropped by a factor of 11 by sampling twice from <span class="inline-equation"><span class="tex">$\tau ^{\prime }=\frac{\tau }{\sqrt {1+k^2}}=19.47$</span></span> instead of sampling from a <span class="inline-equation"><span class="tex">$D_{Z,\tau }$</span></span> with <span class="inline-equation"><span class="tex">$\tau =215$</span></span>. Further improvements on table size are presented in P&ouml;ppelmann [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0058">58</a>] by employing an adaptive mantissa size which halves the table size.</p> 
      <p>P&ouml;ppelmann et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0078">78</a>] proposed a hardware implementation of the CDT sampler which is further optimized in other works [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0060">60</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0079">79</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0080">80</a>]. Du et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0081">81</a>] propose an efficient software implementation of CDT that is vulnerable to timing attacks; this is resolved in Khalid et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0082">82</a>], who suggest a time-independent CDT sampler. P&ouml;ppelmann et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0059">59</a>] combine the CDF and rejection sampling to achieve a compact and reasonably fast Gaussian sampler.</p> 
     </section> 
     <section id="sec-27"> 
      <p> <em> <strong>Knuth-Yao Sampler</strong>.</em> The Knuth-Yao sampler [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0083">83</a>] provides a near optimal sampling (suitable for the high precision sampling) thanks to its near entropy consumption of the random bits required by the sampling algorithm. Assume <span class="inline-equation"><span class="tex">$n$</span></span> to be number of possible values for each random variable <span class="inline-equation"><span class="tex">$r$</span></span> with the probability of <span class="inline-equation"><span class="tex">$p_r$</span></span>. The probability matrix is constructed based on the binary expansion of each variable whose <span class="inline-equation"><span class="tex">$rth ^{}$</span></span> row denotes the binary expansion of <span class="inline-equation"><span class="tex">$p_r$</span></span>. According to the probability matrix, a discrete distribution generating the binary tree (DDG) is built whose <span class="inline-equation"><span class="tex">$ith^{}$</span></span> level corresponds to the <span class="inline-equation"><span class="tex">$ith^{}$</span></span> column of the probability matrix. Sampling is the procedure of walking through the DDG tree until a reaching a leaf and returning its value as the sampling value. At each level, a uniformly random bit indicates whether the left child or right child of the current node should be visited in the future. The Knuth-Yao sampler is suitable for schemes with small standard deviations; thus, Knuth-Yao is not suitable for digital signature because of its slow sampling caused by a high number of random bits. In order to minimize the statistical distance between the approximated distribution and the true Gaussian distribution, the Knuth-Yao sampler needs a large memory to store the probability of the sample points with high precision, which is an issue on resource-constrained platforms. Combining Knuth-Yao and CDT results in about halving the table sizes, which is still prohibitively large; however, the Bernoulli sampler offers the best-precomputed table size [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0033">33</a>].</p> 
      <p>De Clercq et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0084">84</a>] introduce an efficient software implementation of the Ring-LWE-based cryptosystem with Knuth-Yao as a Gaussian sampler. Using a column-wise method for sampling, Roy et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0085">85</a>] propose the first hardware implementation of the Knuth-Yao sampling with a small standard deviation that results in faster sampling; the same authors improved their implementation [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0086">86</a>].</p> 
      <p>Based on the presented results in Buchmann et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0076">76</a>], with the same memory budget, CDT beats rejection sampling and discrete Ziggurat. The Ziggurat sampler outperforms CDT and rejection sampling for larger values of the standard deviation. The Ziggurat sampler bears almost the same speedup as Knuth-Yao, while it improves the memory footprint by a factor of 400. As stated earlier, due to the large standard deviation necessary for a digital signature, the Knuth-Yao sampler is not suitable for digital signatures. Inside an encryption scheme with <span class="inline-equation"><span class="tex">$\sigma _{LP}=3.3$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0046">46</a>], with the same security level (<span class="inline-equation"><span class="tex">$\lambda =64$</span></span>), the Knuth-Yao sampler beats CDT in terms of the number of operations performed in one second per slice of FPGA (Op/s/S) for time-independent implementations [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0082">82</a>]. However, for a time-dependent Gaussian sampler with the same security level (<span class="inline-equation"><span class="tex">$\lambda =94$</span></span>), the CDT sampler proposed by Du and Bai [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0080">80</a>] outperforms the Knuth-Yao implementation of Roy et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0086">86</a>] in term of Op/s/S.</p> 
      <p>The size of precomputed tables in a Bernoulli sampler is two orders of magnitude smaller than those of the CDT and Knuth-Yao samplers [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0033">33</a>]; however, CDT has three times more throughput than Bernoulli for hardware the implementation of <span style="font-family:monospace">BLISS</span> in P&ouml;ppelmann [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0060">60</a>].</p> 
     </section> 
    </section> 
    <section id="sec-28"> 
     <header> 
      <div class="title-info"> 
       <h3> <span class="section-number">2.5</span> Lattice-Based Schemes</h3> 
      </div> 
     </header> 
     <p>Security of the <span style="font-family:monospace">LBC</span> schemes is based on the hardness of solving two average-case problems: SIS [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0087">87</a>] and <span style="font-family:monospace">LWE</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0007">7</a>].</p> 
     <p>Regev [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0007">7</a>] proposed the <span style="font-family:monospace">LWE</span> problem which can be reduced to a worst-case lattice problem like the SIVP. In the proposed scheme, the ciphertext is <span class="inline-equation"><span class="tex">$\mathcal {O}$</span></span>(<span class="inline-equation"><span class="tex">$n$</span></span>log<span class="inline-equation"><span class="tex">$n$</span></span>) times bigger than plaintext; however, in Peikert et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0088">88</a>] ciphertext has the same length order compared to the plaintext. A smaller key size for LWE-based encryption is introduced as the LP scheme in Lindner and Peikert [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0046">46</a>]. Another difference between Regev's encryption scheme and the LP scheme is that the former uses a discrete Gaussian sampler in the key generation step, while LP employs a Gaussian sampler in encryption in addition to the key generation step.</p> 
     <section id="sec-29"> 
      <p> <span class="section-number">2.5.1</span> <em>Public Key Encryption.</em> Public Key Encryption (<span style="font-family:monospace">PKE</span>) is employed to encrypt and decrypt messages between two parties. Additionally, it is a basis for other cryptography schemes such as digital signatures. Generally, it consists of three steps: key generation, encryption, and decryption. The first party (Alice) generates two set of keys and keeps one of them private (<span class="inline-equation"><span class="tex">$sk_{Alice}$</span></span>) and distributes the other key (<span class="inline-equation"><span class="tex">$pk_{Alice}$</span></span>) to another party (Bob). In order to send the message <span class="inline-equation"><span class="tex">$M$</span></span> to Alice, Bob encrypts the message as <span class="inline-equation"><span class="tex">$S=Enc(M,pk_{Alice}),$</span></span> where <span class="inline-equation"><span class="tex">$pk_{Alice}$</span></span> is Alice's public key and Enc is the encryption cipher. Thereafter, Alice decrypts the message as <span class="inline-equation"><span class="tex">$M=Dec(S,sk_{Alice})$</span></span> where <span class="inline-equation"><span class="tex">$Dec$</span></span> is the decryption cipher and <span class="inline-equation"><span class="tex">$sk_{Alice}$</span></span> is Alice's private key. Similarly, Alice should encrypt her message with Bob's public key (<span class="inline-equation"><span class="tex">$pk_{Bob}$</span></span>) if she wants to send a message to Bob. Encryption and decryption ciphers are one-way functions and are known publicly; hence the only secret data are the private keys of the recipients, which should be impossible to uncover using their corresponding public keys. Practical lattice-based PKE schemes are either based on NTRU-related [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0089">89</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0090">90</a>] or LWE [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0007">7</a>] (and its variants including RLWE [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0017">17</a>], MLWE [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0019">19</a>], ILWE [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0091">91</a>], and MPLWE [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0092">92</a>]) assumptions.</p> 
     </section> 
     <section id="sec-30"> 
      <p> <span class="section-number">2.5.2</span> <em>Digital Signature.</em> Digitally signing a document involves sending the signature and document separately. In order to verify the authenticity of the message, the recipient should perform verification on both the signature and the document. A digital signature consists of three steps: key generation, Sign<span class="inline-equation"><span class="tex">$_{sk}$</span></span>, and Verify<span class="inline-equation"><span class="tex">$_{pk}$</span></span>. In the first step, the secret key (<span style="font-family:monospace">sk</span>) and public key (<span style="font-family:monospace">pk</span>) are generated; the signer keeps the secret key and all verifier parties have the public key of the signer. During the sign step, the signer applies the encryption algorithm on input message <span class="inline-equation"><span class="tex">$M$</span></span> with its private key and produces output <span class="inline-equation"><span class="tex">$S$</span></span> as <span class="inline-equation"><span class="tex">$S$</span></span> = Sign<span class="inline-equation"><span class="tex">$_{sk}(M,sk_{signer}$</span></span>). The signer sends the tuple (<span class="inline-equation"><span class="tex">$M,S$</span></span>) to the Verifier who applies Verify<span class="inline-equation"><span class="tex">$_{pk}$</span></span> (<span class="inline-equation"><span class="tex">$M,S$</span></span>) and outputs 1 if <span class="inline-equation"><span class="tex">$M$</span></span> and <span class="inline-equation"><span class="tex">$S$</span></span> are a valid message and signature pair; otherwise, <span class="inline-equation"><span class="tex">$S$</span></span> is rejected as the signature of message <span class="inline-equation"><span class="tex">$M$</span></span>. As an example of the hash and sign procedure, in the sign step, message <span class="inline-equation"><span class="tex">$M$</span></span> is hashed as <span class="inline-equation"><span class="tex">$D=h(M)$</span></span> where <span class="inline-equation"><span class="tex">$D$</span></span> is the digest. Signer applies the encryption algorithm on <span class="inline-equation"><span class="tex">$D$</span></span> with its private key with the output of <span class="inline-equation"><span class="tex">$S=Enc(D,sk_{signer})$</span></span>. Afterward, signer sends the pair (<span class="inline-equation"><span class="tex">$M,S$</span></span>) to the verifier. Subsequently, the verifier uses a public key to decrypt <span class="inline-equation"><span class="tex">$S$</span></span> as <span class="inline-equation"><span class="tex">$D^{\prime }=Dec(S,pk_{signer})$</span></span>. Then, the verifier compares <span class="inline-equation"><span class="tex">$D=h(M)$</span></span> (same hash function is shared between signer and verifier) and <span class="inline-equation"><span class="tex">$D^{\prime }$</span></span>; signature is verified if <span class="inline-equation"><span class="tex">$D^{\prime }=D$</span></span>; otherwise, the signature is rejected. The steps outlined for sign and verify are just an example (used in RSA); sign and verify steps might be slightly different for various signature schemes but follow the same idea.</p> 
      <p>Lattice-based signature schemes belong to one of two classes: hash-and-sign (e.g., GPV [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0093">93</a>]) and Fiat-Shamir signatures (e.g., BG [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0094">94</a>], GLP [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0061">61</a>], and BLISS [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0033">33</a>]). GPV is a provably secure framework to obtain hash-and-sign lattice-based signature schemes; GGH [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0095">95</a>] and NTRUSign [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0096">96</a>] were the first two works to propose lattice-based signatures which are not provably secure (due to the deterministic signing). Because of the high standard deviation of a Gaussian sampler, implementation of lattice-based digital signatures that use a Gaussian sampler is challenging. In addition, the need for hash function components and a rejection step makes digital signature more complex.</p> 
     </section> 
     <section id="sec-31"> 
      <p> <span class="section-number">2.5.3</span> <em>Key Exchange Mechanism.</em> Key exchange is the process of exchanging keys between two parties in the presence of adversaries. If parties use symmetric keys, the same key is shared between them; otherwise, a public key should be exchanged. There are numerous public key exchange methods reported in the literature. For classical cryptography, Diffie–Hellman is a practical public key exchange that has been used widely. Establishing a shared key in a lattice-based key encapsulation (KEM) or key exchange (KEX) scheme can be done by either a <em>reconciliation-based</em> or <em>encryption-based</em> method [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0062">62</a>]. Ding [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0097">97</a>] propose the first lattice-based key agreement using the reconciliation-based method. There are plenty of reconciliation-based key agreement schemes based on LWE (e.g., Frodo [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0032">32</a>]), RLWE (e.g., BCNS [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0098">98</a>] and NewHope [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>]), and MLWE (e.g., Kyer[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0041">41</a>]) that require less bandwidth compared to the simper encryption-based ones (e.g., NewHope-Simple [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0062">62</a>] and NewHope-512/1024 [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0065">65</a>]).</p> 
     </section> 
     <section id="sec-32"> 
      <p> <em> <strong>Fujisaki-Okamoto Transform</strong>.</em> In the random oracle model, an IND-CPA<a class="fn" data-trigger="hover" data-toggle="popover" data-placement="top" href="#fn21" id="foot-fn21"><sup>4</sup></a> public key encryption (<span style="font-family:monospace">PKE</span>) can be transformed into a IND-CCA<a class="fn" data-trigger="hover" data-toggle="popover" data-placement="top" href="#fn22" id="foot-fn22"><sup>5</sup></a> PKE using the <span class="inline-equation"><span class="tex">$Fujisaki-Okamoto$</span></span> (<span style="font-family:monospace">FO</span>) transform [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0099">99</a>]. Hofheinz et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0100">100</a>] introduce a variant of the <span style="font-family:monospace">FO</span> transform that performs transformation from CPA-security into CCA-security in the quantum random oracle model. By applying this variant of <span style="font-family:monospace">FO</span> on a CPA-secure PKE, an IND-CCA key encapsulation mechanism (<span style="font-family:monospace">KEM</span>) is achieved. This transformation is widely used in submitted proposals to NIST that call for post-quantum algorithms [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0101">101</a>] where authors first make an IND-CPA PKE and then build the CCA-KEM with the same parameter space by applying the KEM version of the transform [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0100">100</a>].</p> 
      <p>Many submitted proposals to the NIST PQC standardization use a single proposal (e.g., LOTUS [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0102">102</a>]) that supports both PKE (e.g., LOTUS-PKE) and key agreement (e.g., LOTUS-KEM); in Table <a class="table" href="#tab2">2</a> and Table <a class="table" href="#tab3">3</a>,
       <!--?anchor id="tab3a"?--> we list those proposals as two separate schemes. To avoid redundancy, in Section <a class="sec" href="#sec-33">3</a>, we describe each scheme under only one of the categories of PKE (Section <a class="sec" href="#sec-42">3.2.1</a>) or key exchange mechanism (Section <a class="sec" href="#sec-43">3.2.2</a>). Similarly, to avoid redundancy, both software and hardware implementations are mentioned only once (software implementation in Section <a class="sec" href="#sec-41">3.2</a>; hardware implementation in Section <a class="sec" href="#sec-45">3.3</a>).</p> 
      <div id="tab2" class="table-responsive"> 
       <div class="table-caption"> 
        <span class="table-number">Table 2.</span> 
        <span class="table-title">Contemporary Lattice-Based Schemes</span> 
       </div> 
       <table class="table"> 
        <thead valign="middle"> 
         <tr> 
          <th align="left" valign="middle" style="border-right:1px solid black;border-bottom:1px solid black" rowspan="2"> <strong>Lattice Type</strong> </th> 
          <th align="center" colspan="3" style="border-bottom:1px solid black"> <strong>Schemes</strong> </th> 
         </tr> 
         <tr> 
          <th align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Public Key Encryption</strong> </th> 
          <th align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Digital Signature</strong> </th> 
          <th align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Key Exchange</strong> </th> 
         </tr> 
        </thead> 
        <tbody valign="middle"> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Standard Lattices</strong> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">LP [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0046">46</a>] Lizard [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0103">103</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0104">104</a>] NTRUEnrypt [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0105">105</a>] EMBLEM.CPA [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0106">106</a>] FrodoPKE [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0107">107</a>] LOTUS-PKE [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0102">102</a>] Odd-Manhattan [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0108">108</a>] uRound2.PKE [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0109">109</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">GGH [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0095">95</a>] NTRUSign<span class="inline-equation"><span class="tex">$^{1}$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0096">96</a>] GPV [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0093">93</a>] Lyubashevsky [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0110">110</a>] BG [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0094">94</a>] TESLA [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0111">111</a>]</td> 
          <td align="center" style="border-bottom:1px solid black">Frodo [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0032">32</a>] EMBLEM [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0106">106</a>] FrodoKEM [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0107">107</a>] SPKEX [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0112">112</a>] OKCN/AKCN-LWE/LWR<span class="inline-equation"><span class="tex">$^{4}$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0113">113</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0114">114</a>] Lizard [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0104">104</a>] LOTUS-KEM [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0102">102</a>] Odd-Manhattan [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0108">108</a>] uRound2.PKE [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0109">109</a>]</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Ideal Lattices</strong> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">NTRU [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0089">89</a>] NTRU Prime[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0115">115</a>] Ring-Lizard (RLizard) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0103">103</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0104">104</a>] trunc8 [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0116">116</a>] HILA5 [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0066">66</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0117">117</a>] R.EMBLEM.CPA [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0106">106</a>] NewHope-CPA-PKE [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0065">65</a>] ntru-pke, ss-ntru-pke [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0075">75</a>] u/nRound2.PKE [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0109">109</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">Lyubashevsky [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0118">118</a>] GLP [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0061">61</a>] GPV [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0119">119</a>] BLISS [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0033">33</a>] BLISS-B [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0120">120</a>] Ring-TESLA [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0121">121</a>] TESLA<span class="inline-equation"><span class="tex">$\#$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0051">51</a>] BLZZRD [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0050">50</a>] GLYPH<span class="inline-equation"><span class="tex">$^{2}$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0122">122</a>] FALCON [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0123">123</a>] qTESLA [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0124">124</a>]</td> 
          <td align="center" style="border-bottom:1px solid black">JARJAR, NewHope [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>] NewHope-Simple [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0062">62</a>] BCNS [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0098">98</a>] HILA5 [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0066">66</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0117">117</a>] NTRU KEM [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0125">125</a>] Ding Key Exchange [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0126">126</a>] R.EMBLEM [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0106">106</a>] OKCN/AKCN-RLWE<span class="inline-equation"><span class="tex">$^{4}$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0113">113</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0114">114</a>] AKCN/OKCN-SEC<span class="inline-equation"><span class="tex">$^{4}$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0114">114</a>] LIMA-sp/2p [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0068">68</a>] RLizard [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0104">104</a>] NewHope-CPA/CCA-KEM [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0065">65</a>] ntru-kem, ss-ntru-kem [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0075">75</a>] NTRU-HRSS-KEM [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0127">127</a>] Streamlined-NTRU-Prime, NTRU-LPRime [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0128">128</a>] u/nRound2.KEM [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0109">109</a>]</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Module Lattices</strong> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">Kyber PKE [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0041">41</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0069">69</a>] AKCN-MLWE-CCA<span class="inline-equation"><span class="tex">$^{4}$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0114">114</a>] KINDI<span class="inline-equation"><span class="tex">$_{CPA}$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0129">129</a>] SABER [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0130">130</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">Dilithium [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0131">131</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0132">132</a>] pqNTRUSign [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0074">74</a>]</td> 
          <td align="center" style="border-bottom:1px solid black">Kyber KEM [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0041">41</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0069">69</a>] CNKE, OKCN/AKCN-MLWE<span class="inline-equation"><span class="tex">$^{4}$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0114">114</a>] KINDI<span class="inline-equation"><span class="tex">$_{CCA-KEM}$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0129">129</a>] SABER [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0130">130</a>] THREEBEARS<span class="inline-equation"><span class="tex">$^{3}$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0091">91</a>]</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black"> <strong>Middle Product Lattices</strong> </td> 
          <td align="center" style="border-right:1px solid black">Titanium-CPA [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0070">70</a>]</td> 
          <td align="center" style="border-right:1px solid black">-</td> 
          <td align="center">Titanium-CCA [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0070">70</a>]</td> 
         </tr> 
        </tbody> 
        <tfoot> 
         <tr> 
          <td colspan="4"> <p id="fn1"> <span class="inline-equation"><span class="tex">$^{1}$</span></span>Adapted from GGH digital signature scheme.<span class="inline-equation"><span class="tex">$^{2}$</span></span>Adapted from GLP digital signature scheme.<span class="inline-equation"><span class="tex">$^{3}$</span></span>Based on the integer version of the MLWE problem.<span class="inline-equation"><span class="tex">$^{4}$</span></span>From the KCL [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0114">114</a>] family.</p> </td> 
         </tr> 
        </tfoot> 
       </table> 
      </div> 
      <div id="tab3" class="table-responsive"> 
       <div class="table-caption"> 
        <span class="table-number">Table 3.</span> 
        <span class="table-title">Comparison of Contemporary Lattice-Based Public Key Encryption and Key Exchange Schemes</span> 
       </div> 
       <table class="table"> 
        <thead valign="middle"> 
         <tr> 
          <th align="center" valign="middle" style="border-right:1px solid black;border-bottom:1px solid black" rowspan="2"> <strong>Scheme</strong> </th> 
          <th align="center" colspan="2" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>PQ security</strong> </th> 
          <th align="center" style="border-right:1px solid black;border-bottom:1px solid black" rowspan="2"> <strong>Failure Probablity<span class="inline-equation"><span class="tex">$^{1}$</span></span> </strong> </th> 
          <th align="center" colspan="3" style="border-bottom:1px solid black"> <strong>Size (bytes)</strong> </th> 
         </tr> 
         <tr> 
          <th align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>SVP</strong> </th> 
          <th align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>CCA</strong> </th> 
          <th align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Secret Key</strong> </th> 
          <th align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Public Key</strong> </th> 
          <th align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Ciphertext</strong> </th> 
         </tr> 
        </thead> 
        <tbody> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">BCNS (KEX) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0098">98</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">78</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">-</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">?</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">4096</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">4096</td> 
          <td align="center" style="border-bottom:1px solid black">4224</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">JarJar (KEX) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">118</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">-</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">55</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">896</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">928</td> 
          <td align="center" style="border-bottom:1px solid black">1024</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">NewHope (KEX) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">255</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">-</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">61</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1792</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1824</td> 
          <td align="center" style="border-bottom:1px solid black">2048</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Frodo rec. (KEX) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0032">32</a>]<span class="inline-equation"><span class="tex">$^{2}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">130</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">-</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">36</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1280</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">11296</td> 
          <td align="center" style="border-bottom:1px solid black">11288</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Kyber light (KEX) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0041">41</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">102</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">169</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">169</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">832</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">736</td> 
          <td align="center" style="border-bottom:1px solid black">832</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Kyber rec. (KEX)[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0041">41</a>]<span class="inline-equation"><span class="tex">$^{2}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">161</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">142</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">142</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1248</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1088</td> 
          <td align="center" style="border-bottom:1px solid black">1184</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Kyber paranoid (KEX) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0041">41</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">218</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">145</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">145</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1664</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1440</td> 
          <td align="center" style="border-bottom:1px solid black">1536</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">NTRU KEM [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0125">125</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">123</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <span class="inline-equation"><span class="tex">$\infty$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <span class="inline-equation"><span class="tex">$\infty$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1422</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1140</td> 
          <td align="center" style="border-bottom:1px solid black">1281</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">NTRU Prime (KEM) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0115">115</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">129</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <span class="inline-equation"><span class="tex">$\infty$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <span class="inline-equation"><span class="tex">$\infty$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1417</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1232</td> 
          <td align="center" style="border-bottom:1px solid black">1141</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">HILA5 (KEM/PKE) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0117">117</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">255</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">135</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">135</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1792</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1824</td> 
          <td align="center" style="border-bottom:1px solid black">2012</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">trunc8 [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0116">116</a>]<span class="inline-equation"><span class="tex">$\S$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">131</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">-</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">45</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">128</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1024</td> 
          <td align="center" style="border-bottom:1px solid black">1024</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">NTRU ees743ep1 (PKE) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0089">89</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">159</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">-</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">112</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1120</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1027</td> 
          <td align="center" style="border-bottom:1px solid black">980</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Ding Key Exchange [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0126">126</a>]<span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256<span class="inline-equation"><span class="tex">$^{*}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">-</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">60</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">3072</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">2064</td> 
          <td align="center" style="border-bottom:1px solid black">2176</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">EMBLEM (KEM)[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0106">106</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-128</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">-</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">140</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">2039180</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">2036736</td> 
          <td align="center" style="border-bottom:1px solid black">78368</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">R.EMBLEM (KEM) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0106">106</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-128</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">-</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">140</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">6144</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">4096</td> 
          <td align="center" style="border-bottom:1px solid black">3104</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">FrodoKEM (Frodo-976) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0107">107</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-192</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">199</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">31272</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">15632</td> 
          <td align="center" style="border-bottom:1px solid black">15762</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">FrodoKEM (Frodo-640) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0107">107</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-128</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">148</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">19872</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">9616</td> 
          <td align="center" style="border-bottom:1px solid black">9736</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">KCL (e.g., AKCN-RLWE) (KEM) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0114">114</a>]<span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">40</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1664</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1,696</td> 
          <td align="center" style="border-bottom:1px solid black">2083</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">KINDI (e.g., KINDI-512-3-2-1) (PKE/KEM) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0129">129</a>]<span class="inline-equation"><span class="tex">$^{++}$</span></span> <span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">276</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">2752</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">2368</td> 
          <td align="center" style="border-bottom:1px solid black">3392</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">LAC (e.g., LAC256) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0067">67</a>]<span class="inline-equation"><span class="tex">$^{++}$</span></span> <span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">115</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">2080</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1056</td> 
          <td align="center" style="border-bottom:1px solid black">2048</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">LIMA (e.g., CCA.LIMA-2p2048) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0068">68</a>]<span class="inline-equation"><span class="tex">$^{++}$</span></span> <span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">SHA-512</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">314</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">18433</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">12289</td> 
          <td align="center" style="border-bottom:1px solid black">7299</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">LIMA (e.g., CCA.LIMA-sp2062)[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0068">68</a>]<span class="inline-equation"><span class="tex">$^{++}$</span></span> <span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">SHA-512</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">244</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">24745</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">16497</td> 
          <td align="center" style="border-bottom:1px solid black">9787</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Lizard.CCA (PKE) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0104">104</a>]<span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">381</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">557056</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">6553600</td> 
          <td align="center" style="border-bottom:1px solid black">3328</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">RLizard.CCA (PKE) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0104">104</a>]<span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">305</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">513</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">8192</td> 
          <td align="center" style="border-bottom:1px solid black">8512</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Lizard.KEM [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0104">104</a>]<span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">381</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">34880</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">4587520</td> 
          <td align="center" style="border-bottom:1px solid black">35904</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">RLizard.KEM [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0104">104</a>]<span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">305</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">769</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">8192</td> 
          <td align="center" style="border-bottom:1px solid black">8256</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">LOTUS (PKE/KEM) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0102">102</a>]<span class="inline-equation"><span class="tex">$^{++}$</span></span> <span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1630720</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1470976</td> 
          <td align="center" style="border-bottom:1px solid black">1768</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">NewHope1024 (KEM) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0065">65</a>]<span class="inline-equation"><span class="tex">$^{5}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">216</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">3680</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1824</td> 
          <td align="center" style="border-bottom:1px solid black">2208</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">NewHope512 (KEM) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0065">65</a>]<span class="inline-equation"><span class="tex">$^{5}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-128</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">213</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1888</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">928</td> 
          <td align="center" style="border-bottom:1px solid black">1220</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Streamline-NTRU-Prime (KEM) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0128">128</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <span class="inline-equation"><span class="tex">$\infty$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1600</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1218</td> 
          <td align="center" style="border-bottom:1px solid black">1047</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">NTRU-LPRime (KEM) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0128">128</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <span class="inline-equation"><span class="tex">$\infty$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1238</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1047</td> 
          <td align="center" style="border-bottom:1px solid black">1175</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">NTRU-HRSS-KEM [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0127">127</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-128</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <span class="inline-equation"><span class="tex">$\infty$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1418</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1138</td> 
          <td align="center" style="border-bottom:1px solid black">1278</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">NTRUEncrypt (e.g., ntru-kem-743) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0075">75</a>]<span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">112</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1173</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1023</td> 
          <td align="center" style="border-bottom:1px solid black">1023</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Odd-Manhattan (KEM) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0108">108</a>]<span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">?</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">4456650</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">4454241</td> 
          <td align="center" style="border-bottom:1px solid black">616704</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">uRound2 (uround2_kem_nd_l5) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0109">109</a>]<span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">65</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">169</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">709</td> 
          <td align="center" style="border-bottom:1px solid black">868</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">nRound2 (nround2_kem_nd_l5) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0109">109</a>]<span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">45</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">165</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">691</td> 
          <td align="center" style="border-bottom:1px solid black">818</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">uRound2 (uround2_pke_nd_l5) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0109">109</a>]<span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">137</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1039</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">830</td> 
          <td align="center" style="border-bottom:1px solid black">953</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">nRound2 (nround2_pke_nd_l5) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0109">109</a>]<span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">164</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1039</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">830</td> 
          <td align="center" style="border-bottom:1px solid black">1017</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">SABER (PKE/KEM) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0130">130</a>]<span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">165</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">3040</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1312</td> 
          <td align="center" style="border-bottom:1px solid black">1472</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">THREEBEARS (KEM) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0091">91</a>]<span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">188</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">40</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1584</td> 
          <td align="center" style="border-bottom:1px solid black">1697</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Titanium-CPA (PKE) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0070">70</a>]<span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">30</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">32</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">23552</td> 
          <td align="center" style="border-bottom:1px solid black">8320</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Titanium-CCA (KEM) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0070">70</a>]<span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"></td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES-256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">85</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">26944</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">26912</td> 
          <td align="center" style="border-bottom:1px solid black">8352</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">DH-3072</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">-</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">-</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">?</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">416</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">384</td> 
          <td align="center" style="border-bottom:1px solid black">384</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black">ECDH-256</td> 
          <td align="center" style="border-right:1px solid black">-</td> 
          <td align="center" style="border-right:1px solid black">-</td> 
          <td align="center" style="border-right:1px solid black">?</td> 
          <td align="center" style="border-right:1px solid black">32</td> 
          <td align="center" style="border-right:1px solid black">32</td> 
          <td align="center">64</td> 
         </tr> 
        </tbody> 
        <tfoot> 
         <tr> 
          <td colspan="7"> <p id="fn5"> <span class="inline-equation"><span class="tex">$^{1}$</span></span>Failure is <span class="inline-equation"><span class="tex">$-log_2$</span></span> of the failure probability.<span class="inline-equation"><span class="tex">$^{2}$</span></span>For recommended parameters.<span class="inline-equation"><span class="tex">$^{3}$</span></span>AES-128 and AES-192 are also available.<span class="inline-equation"><span class="tex">$^{4}$</span></span>Scheme with the highest security is selected.<span class="inline-equation"><span class="tex">$^{5}$</span></span>INP-CPA KEM is also available.<span class="inline-equation"><span class="tex">$\S$</span></span>Ring-LWE encryption and authentication system.<span class="inline-equation"><span class="tex">$^{+}$</span></span>INP-CPA PKE is available.<span class="inline-equation"><span class="tex">$^{*}$</span></span>The scheme is at least as hard as AES-256 as a requirement by NIST (same is applied to schemes with security of AES-128, AES-192 and SHA-512).</p> </td> 
         </tr> 
        </tfoot> 
       </table> 
      </div> 
      <p>The contemporary <span style="font-family:monospace">LBC</span> schemes extant in the literature are listed in Table <a class="table" href="#tab2">2</a>. Details on the security level, public key, secret key, and ciphertext size of lattice-based PKE and key establishment (<span style="font-family:monospace">KEX</span>/<span style="font-family:monospace">KEM</span>) schemes can be seen in Table <a class="table" href="#tab3">3</a>. Details on the security level, secret key, public key, and signature size of the lattice-based digital signature schemes are listed in Table <a class="table" href="#tab4">4</a>.</p> 
      <div id="tab4" class="table-responsive"> 
       <div class="table-caption"> 
        <span class="table-number">Table 4.</span> 
        <span class="table-title">Comparison of Popular Lattice-Based Key Digital Signature Schemes</span> 
       </div> 
       <table class="table"> 
        <thead valign="middle"> 
         <tr> 
          <th align="center" valign="middle" style="border-right:1px solid black;border-bottom:1px solid black" rowspan="2"> <strong>Scheme</strong> </th> 
          <th align="center" colspan="2" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Security</strong> </th> 
          <th align="center" colspan="3" style="border-bottom:1px solid black"> <strong>Size</strong> </th> 
         </tr> 
         <tr> 
          <th align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>PreQ</strong> </th> 
          <th align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>PostQ</strong> </th> 
          <th align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Secret Key</strong> </th> 
          <th align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Public Key</strong> </th> 
          <th align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Signature</strong> </th> 
         </tr> 
        </thead> 
        <tbody> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">GPV [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0093">93</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">100</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">?</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">256 B</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1.5 kB</td> 
          <td align="center" style="border-bottom:1px solid black">1.186 kB</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">BG [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0094">94</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">128</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">?</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">0.87 MB</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1.54 MB</td> 
          <td align="center" style="border-bottom:1px solid black">1.46 kB</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">TESLA–128 [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0111">111</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">128</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">?</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1.01 MB</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1.33 MB</td> 
          <td align="center" style="border-bottom:1px solid black">1.280 kB</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">TESLA–256 [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0111">111</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">128</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1.057 MB</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">2.2 MB</td> 
          <td align="center" style="border-bottom:1px solid black">1.688 kB</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">GLP [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0061">61</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">100</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">&lt;80</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">256 B</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1.5 kB</td> 
          <td align="center" style="border-bottom:1px solid black">1.186 kB</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">BLISS-I [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0033">33</a>]<span class="inline-equation"><span class="tex">$^{2}$</span></span> BLISS-BI [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0120">120</a>]<span class="inline-equation"><span class="tex">$^{1}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">128</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">&lt;66</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">256 B</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">896 B</td> 
          <td align="center" style="border-bottom:1px solid black">700 B</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">TESLA<span class="inline-equation"><span class="tex">$\#$</span></span>–I [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0051">51</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">128</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">64</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">2.112 kB</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">3.328 kB</td> 
          <td align="center" style="border-bottom:1px solid black">1.616 kB</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">TESLA<span class="inline-equation"><span class="tex">$\#$</span></span>–II [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0051">51</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">128</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">4.608 kB</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">7.168 kB</td> 
          <td align="center" style="border-bottom:1px solid black">3.488 kB</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Ring-TESLA-II [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0121">121</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">118</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">64</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1.92 kB</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">3.328 kB</td> 
          <td align="center" style="border-bottom:1px solid black">1.568 kB</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Dilithium rec. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0131">131</a>]<span class="inline-equation"><span class="tex">$^{3}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">138</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">125</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">3.504 kB</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1.472 kB</td> 
          <td align="center" style="border-bottom:1px solid black">2.701 kB</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">Dilithium high. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0131">131</a>]<span class="inline-equation"><span class="tex">$^{4}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">176</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">160</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">3.856 KB</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1.760 kB</td> 
          <td align="center" style="border-bottom:1px solid black">3.366 kB</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">FALCON (falcon1024) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0123">123</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">128</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">8.193 kB</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1.793 kB</td> 
          <td align="center" style="border-bottom:1px solid black">1.233 kB</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">FALCON (falcon768) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0123">123</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES192</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">96</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">6.145 kB</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">1.441 kB</td> 
          <td align="center" style="border-bottom:1px solid black">1.077 kB</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">FALCON (falcon512) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0123">123</a>]</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES128</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">64</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">4.097 kB</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">897 B</td> 
          <td align="center" style="border-bottom:1px solid black">690B</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">pqNTRUsign [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0074">74</a>]<span class="inline-equation"><span class="tex">$^{5}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">128</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">2.604 kB</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">2.065 kB</td> 
          <td align="center" style="border-bottom:1px solid black">2.065 kB</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">qTESLA (qTesla_256) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0124">124</a>]<span class="inline-equation"><span class="tex">$^{5}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES256</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">128</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">8.256 kB</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">8.224 kB</td> 
          <td align="center" style="border-bottom:1px solid black">6.176 kB</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">qTESLA (qTesla_192) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0124">124</a>]<span class="inline-equation"><span class="tex">$^{5}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES192</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">96</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">8.256 kB</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">8.224 kB</td> 
          <td align="center" style="border-bottom:1px solid black">6.176 kB</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">qTESLA (qTesla_128) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0124">124</a>]<span class="inline-equation"><span class="tex">$^{5}$</span></span> </td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">AES128</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">64</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">2.112 kB</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">4.128 kB</td> 
          <td align="center" style="border-bottom:1px solid black">3.104 kB</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black;border-bottom:1px solid black">DSA-3072</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">128</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">0</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">416 B</td> 
          <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">384 B</td> 
          <td align="center" style="border-bottom:1px solid black">384 B</td> 
         </tr> 
         <tr> 
          <td align="left" style="border-right:1px solid black">ECDSA-256</td> 
          <td align="center" style="border-right:1px solid black">128</td> 
          <td align="center" style="border-right:1px solid black">0</td> 
          <td align="center" style="border-right:1px solid black">32 B</td> 
          <td align="center" style="border-right:1px solid black">32 B</td> 
          <td align="center">64 B</td> 
         </tr> 
        </tbody> 
        <tfoot> 
         <tr> 
          <td colspan="6"> <p id="fn13"> <span class="inline-equation"><span class="tex">$^{1}$</span></span>BLISS-BI speeds up BLISS-I by factor of <span class="inline-equation"><span class="tex">$1.2\times$</span></span>.<span class="inline-equation"><span class="tex">$^{2}$</span></span>Speed optimized.<span class="inline-equation"><span class="tex">$^{3}$</span></span>For recommended parameters.<span class="inline-equation"><span class="tex">$^{4}$</span></span>The highest security level.<span class="inline-equation"><span class="tex">$^{5}$</span></span>For both Gaussian-1024 and Unifrom-1024 variants.</p> </td> 
         </tr> 
        </tfoot> 
       </table> 
      </div> 
     </section> 
    </section> 
   </section> 
   <section id="sec-33"> 
    <header> 
     <div class="title-info"> 
      <h2> <span class="section-number">3</span> IMPLEMENTATION CHALLENGES</h2> 
     </div> 
    </header> 
    <p>In this section, we consider various implementations of LBC schemes using software, hardware, software/hardware codesign, and DSP techniques. First we focus on the implementation of key arithmetic modules such as the Gaussian sampler and matrix/polynomial multiplication in Section <a class="sec" href="#sec-34">3.1</a>. Software and hardware implementations of LBC schemes are described in Section <a class="sec" href="#sec-41">3.2</a> and Section <a class="sec" href="#sec-45">3.3</a>, respectively. Section <a class="sec" href="#sec-49">3.4</a> describes implementations of lattice-based schemes using hardware/software codesign techniques. The only implementation of a lattice-based scheme using DPS implementation is described in Section <a class="sec" href="#sec-50">3.5</a>.</p> 
    <p>Table <a class="table" href="#tab5">5</a> presents a birds-eye view of popular implementation schemes and can be helpful as a visual/organizational reference during the discussion of various implementation schemes.</p> 
    <div id="tab5" class="table-responsive"> 
     <div class="table-caption"> 
      <span class="table-number">Table 5.</span> 
      <span class="table-title">Popular Implementation of Lattice-Based Schemes</span> 
     </div> 
     <table class="table"> 
      <thead valign="middle"> 
       <tr> 
        <th align="center" valign="middle" style="border-right:1px solid black;border-bottom:1px solid black" rowspan="2"> <strong>Lattice Type</strong> </th> 
        <th align="center" colspan="3" style="border-bottom:1px solid black"> <strong>Schemes</strong> </th> 
       </tr> 
       <tr> 
        <th align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Software</strong> </th> 
        <th align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Hardware</strong> </th> 
        <th align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Hardware/Software</strong> </th> 
       </tr> 
      </thead> 
      <tbody valign="middle"> 
       <tr> 
        <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Standard Lattices</strong> </td> 
        <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">PKE: [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0103">103</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0104">104</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0105">105</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0106">106</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0107">107</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0102">102</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0108">108</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0109">109</a>] DS: [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0094">94</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0119">119</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0133">133</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0111">111</a>] KEX: [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0112">112</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0032">32</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0106">106</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0107">107</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0112">112</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0113">113</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0114">114</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0104">104</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0102">102</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0108">108</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0109">109</a>]</td> 
        <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">PKE: [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0031">31</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0106">106</a>]</td> 
        <td align="center" style="border-bottom:1px solid black">-</td> 
       </tr> 
       <tr> 
        <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Ideal Lattices</strong> </td> 
        <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">PKE: [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0084">84</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0134">134</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0038">38</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0135">135</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0136">136</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0137">137</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0115">115</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0103">103</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0104">104</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0116">116</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0066">66</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0117">117</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0106">106</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0065">65</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0075">75</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0109">109</a>] DS: [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0061">61</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0138">138</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0119">119</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0139">139</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0060">60</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0140">140</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0038">38</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0141">141</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0142">142</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0119">119</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0033">33</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0120">120</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0121">121</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0051">51</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0050">50</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0122">122</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0123">123</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0124">124</a>] KEX: [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0097">97</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0113">113</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0062">62</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0063">63</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0143">143</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0125">125</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0062">62</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0098">98</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0066">66</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0117">117</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0126">126</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0106">106</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0113">113</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0114">114</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0114">114</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0068">68</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0104">104</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0065">65</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0075">75</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0127">127</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0128">128</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0109">109</a>]</td> 
        <td style="border-right:1px solid black;border-bottom:1px solid black" align="center">PKE: [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0056">56</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0079">79</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0037">37</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0059">59</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0106">106</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0135">135</a>] DS: [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0061">61</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0060">60</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0144">144</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0145">145</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0146">146</a>] KEX: [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0106">106</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0071">71</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0147">147</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0146">146</a>]</td> 
        <td style="border-bottom:1px solid black" align="center">DS: [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0148">148</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0149">149</a>]</td> 
       </tr> 
       <tr> 
        <td align="center" style="border-right:1px solid black;border-bottom:1px solid black"> <strong>Module Lattices</strong> </td> 
        <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">PKE: [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0041">41</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0069">69</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0130">130</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0129">129</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0114">114</a>] DS: [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0131">131</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0132">132</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0074">74</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0150">150</a>] KEM: [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0041">41</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0069">69</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0091">91</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0130">130</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0129">129</a>] [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0114">114</a>]</td> 
        <td align="center" style="border-right:1px solid black;border-bottom:1px solid black">-</td> 
        <td align="center" style="border-bottom:1px solid black">-</td> 
       </tr> 
       <tr> 
        <td align="center" style="border-right:1px solid black"> <strong>Middle Product Lattices</strong> </td> 
        <td align="center" style="border-right:1px solid black">PKE:[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0070">70</a>] KEM:[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0070">70</a>]</td> 
        <td align="center" style="border-right:1px solid black">-</td> 
        <td align="center">-</td> 
       </tr> 
      </tbody> 
     </table> 
    </div> 
    <section id="sec-34"> 
     <header> 
      <div class="title-info"> 
       <h3> <span class="section-number">3.1</span> Implementation of Arithmetic Modules</h3> 
      </div> 
     </header> 
     <p>In this section, practical implementations of the Gaussian sampler and polynomial multiplication on both hardware and software platforms are presented. There is only one hardware implementation of matrix multiplication (for standard lattices) available in the literature, which we detail in Section <a class="sec" href="#sec-38">3.1.2</a>.</p> 
     <section id="sec-35"> 
      <p> <span class="section-number">3.1.1</span> <em>Gaussian Sampler.</em> Dwarakanath et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0151">151</a>] provide a survey of different algorithms for computing the exponential function efficiently on resource-constrained devices regarding memory capacity. In order to decrease the memory footprint, pipelining the sampling algorithm is used, in which the authors divide the distribution curve into rectangles with the same probability and choose the rectangles according to the Knuth-Yao method, which means the Knuth-Yao method is employed another round for rectangle itself. Tail probabilities in discrete distribution are relatively small, which provide the chance of approximating them with lower precision arithmetic. Consequently, on-the-fly tail construction using standard double-precision floating-point precision is suggested. Although the offered idea could significantly reduce the memory (lookup table) footprint since lookup tables only store non-tail probabilities, considerable floating point arithmetic overhead is imposed on the system.</p> 
     </section> 
     <section id="sec-36"> 
      <p> <em> <strong>Software Implementation</strong>.</em> Buchmann et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0076">76</a>] design and implement, in C++, a flexible Gaussian sampler named Ziggurat which sets a tradeoff between memory footprint, precision, and execution time. The area under the Probability Density Function (<span style="font-family:monospace">PDF</span>) is divided into rectangles with the same area that is employed to minimize calculation of an expensive exponential function. More rectangles (greater memory footprint) results in higher precision and better performance. The Ziggurat sampler is attractive because of the potential flexibility that makes it a good candidate to use in crypto-engines of either high-performance servers (allocate more memory to reach better performance and precision) or low-speed resource-constrained embedded devices (use few numbers of rectangles to minimize memory consumption). In order to increase the performance of the Ziggurat sampler, more rectangles are required, which imposes significant memory overhead since it needs to recompute all the rectangles and save them in memory. A better way to improve the Ziggurat sampler is to increase the number of approximation lines (by adding two extra points), which culminates in decreasing the number of exponential function calculations [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0152">152</a>]. In other words, more approximation lines decrease the probability of rejection by providing a more precise approximation of the curve. Consequently, performance and memory are improved by employing more approximate lines.</p> 
     </section> 
     <section id="sec-37"> 
      <p> <em> <strong>Hardware Implementation</strong>.</em> Roy et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0085">85</a>] implement the first high-precision and low-area hardware implementation of the Knuth-Yao sampler using a small standard deviation on a Xilinx Virtex5 FPGA. Knuth-Yao involves a random walk tree traversal which imposes expensive sequential bit scanning and a wide ROM footprint. To improve performance, the authors traverse the Discrete Distribution Generating (<span style="font-family:monospace">Ddg</span>) tree by employing the relative distance of intermediate nodes. Column-wise storing of the samples’ probability in ROM improves the performance of the sampler. Numerous zeros in the probability matrix are well compressed by applying one-step compression, which culminates in a near-optimal number of random bits to generate a sample point. As presented, the Knuth-Yao sampler suffers from vulnerability to timing and power attacks due to the nonconstant time random walk, which is solved by a random shuffle approach to eliminate leaking timing information [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0086">86</a>]. The authors offer the solution (random shuffle) but do not evaluate the hardware implementation of the shuffler. In the new implementation, the efficiency of the Knuth-Yao is enhanced by employing small LUTs with the input of the random bits and output of the sample point with high probability or an intermediate node positioned in the discrete distribution generation tree. Employing a lookup table with 8-bit input results in hitting a sample point (eliminate expensive bit-scanning procedure) with the probability of 97% by eight random bits. Additionally, a more compact sampler is achieved by reducing the width of the ROM and random bit generator.</p> 
      <p>Du et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0080">80</a>] implement a precise (large tail bound) and area-efficient Cumulative Distribution Function (<span style="font-family:monospace">CDF</span>) inversion variant of the discrete Gaussian sampler on Xilinx Spartan-6 FPGA. They reduce area occupation by employing piece-wise comparison (which results in 90% saving in the random bits) and avoiding a comparison of large numbers, which is an improvement on P&ouml;ppelmann and G&uuml;neysu [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0079">79</a>]. Further improvement is achieved by employing small LUTs with high hit rates, which results in a performance improvement. Performance of the proposed Gaussian sampler is improved twofold by the same authors with a software implementation (Intel Core i7-4771) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0081">81</a>]. The primary obstacle to improving performance on a general-purpose processor is the large number of random bits that are consumed by the sampler to generate a random number. This obstacle is alleviated (around 30%) by employing multilevel fast LUT (using eight smaller lookup table instead of one). Further speed improvement of the sampler is gained by applying the multithreading technique. The main security drawback of both hardware and software implementation of the discrete Gaussian sampler by Du and Bai is its vulnerability to timing attacks because of the nonconstant time traversal of the binary tree [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0052">52</a>].</p> 
      <p>Howe et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0052">52</a>] propose a comprehensive evaluation of various practical hardware implementation of time-independent discrete Gaussian samplers, including Bernoulli, discrete Ziggurat (First hardware design on FPGA), CDT, and Knuth-Yao. They present each sampler's weaknesses/strengths and perform the comparison with state-of-the-art designs regarding memory footprint, performance, and FPGA resource consumption. The authors analyze different quantum secure parameters for a PKE scheme and digital signature. A CDT Gaussian sampler provides higher throughput with lower memory footprint when used for digital signature. Due to the inferior performance of the hardware Ziggurat implementation, the authors discourage the use of the Ziggurat sampler for digital signatures. Similarly, the CDT sampler achieves better balanced area and throughput for public key encryption, and allowing the use of BRAMs makes the Knuth-Yao variant a much superior design in terms of area and throughput. The authors use BRAMs to decrease occupied slices in the FPGA and to save precomputed values, which significantly improves performance.</p> 
      <p>P&ouml;ppelmann and G&uuml;neysu [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0059">59</a>] propose an area-optimized hardware implementation of the Bernoulli sampler that employs Bernoulli evaluation instead of evaluation of <span style="font-family:monospace">exp()</span>. Rejection probability is high due to the absence of binary Gaussian distribution (easy to sample intermediate sampler), which results in increasing the entropy consumption and runtime. Although the proposed Gaussian sampler is suitable for encryption schemes, it would be challenging to employ inside digital signatures as the sampling component. P&ouml;ppelmann et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0060">60</a>] propose a hardware implementation of the Bernoulli sampler with binary Gaussian distribution for a <span style="font-family:monospace">BLISS</span> scheme on Xilinx Spartan-6 FPGA.</p> 
      <p>G&ouml;ttert et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0056">56</a>] propose the first hardware implementation of the discrete Gaussian sampler. They use rejection sampling in their software implementation; however, because of the obligatory floating point arithmetic, they prefer to employ lookup tables in their hardware implementation, in which the Gaussian distributed values in the stored array are indexed using a pseudo-random bit generator. The proposed sampler has unsatisfactory precision, far from the golden discrete Gaussian distribution due to its small tail bound. The authors employ a fully parallel architecture to design a polynomial multiplier which provides high throughput but makes the design extremely big; it cannot be fitted into the largest Virtex-7 FPGA family.</p> 
      <p>Roy et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0037">37</a>] propose a compact Ring-LWE cryptoprocessor to optimize NTT multiplication, which is accomplished by a reduction in fixed computation (4 NTT instead of 5 NTT) and in reducing the prescaling overhead. In addition, NTT memory access is minimized by storing two coefficients in a single word, processing two pairs of coefficients together, and eliminating idle cycles. The authors avoid using ROM to save twiddle factors and instead compute twiddle factors on demand. In addition, they reduce security by limiting coefficients of the secret key to be binary instead of Gaussian distributed, which allows multiplication to be replaced by addition operations. Small lookup tables are used in the Knuth-Yao discrete Gaussian sampler to avoid expensive bit scanning [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0085">85</a>] and to improve speedup; additionally, ROM widths are reduced, which results in a more compact and faster sampler than Bernoulli [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0059">59</a>].</p> 
     </section> 
     <section id="sec-38"> 
      <p> <span class="section-number">3.1.2</span> <em>Multiplier.</em> </p> 
     </section> 
     <section id="sec-39"> 
      <p> <em> <strong>Software Implementation</strong>.</em> Emeliyanenko [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0153">153</a>] proposes an efficient 24-bit modular multiplication to achieve high throughput polynomial multiplications using the NTT algorithm (on an Nvidia GPU). Employing a CUDA FFT kernel and Chinese Remainder Theorem (CRT), the proposed method provides better speedup compared to the NTL [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0154">154</a>] libraries for moderate coefficient bit-length.</p> 
      <p>Akleylek et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0155">155</a>] propose sparse polynomial multiplication for the first time, which improves the performance of the digital signature proposed in G&uuml;neysu [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0144">144</a>] by 34%. The authors implement Sch&ouml;nhage-Strassen polynomial multiplication on an NVIDIA GPU and compare its performance with existing multiplication schemes, including iterative NTT, parallel NTT, and CUDA-based FFT (cuFFT) for different integer sizes.</p> 
      <p>Akleylek et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0156">156</a>] propose a software implementation (Intel Core i5-3210M) of sparse polynomial multiplication using a sliding window that results in around an 80% speed improvement compared to NTT [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0138">138</a>]. The authors assume polynomials with coefficients with three possible values including -1,0 and +1. Multiplication by zero is avoided, and for +1 and -1 cases, addition and subtraction are used, respectively. The method can be used for polynomials with arbitrary coefficients by substituting a multiplication with a loop of additions. Performance depends on a high number of zeros and numerous identical patterns, which makes the system prone to timing attacks.</p> 
      <p> <span style="font-family:monospace">FNLlib</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0157">157</a>] is a scalable, efficient, and open source C++ library containing optimized arithmetic operations on the polynomials for ideal LBC schemes. Compared to the generic libraries for polynomial arithmetic, several orders of magnitude improvement in the speed is achieved by employing algorithm optimizations, including fixed-sized <span style="font-family:monospace">CRT</span>, scalar modular multiplication and NTT algorithm, and programming-level optimizations, such as SSE and AVX2 SIMD. The authors use NFLlib for the RLWE encryption scheme and homomorphic encryption, and compare their efficiency with classical cryptographic schemes (like RSA) and libraries (like NTL).</p> 
      <p>Longa et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0158">158</a>] propose an efficient modular reduction by limiting the coefficient length to 32 bits. Consequently, by employing the new technique in NTT, the reduction is only required after multiplication. Combined with the lazy reduction in NTT, the speed improvement of 1.9&times; for a C implementation (on a 64-bit platform) and 1.25&times; for an AVX2 vector implementation compared to NewHope (tolerant against timing attacks) is achieved. However, due to the lack of a 64-bit register, the proposed reduction technique does not provide speed-up on 32-bit microcontrollers [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0063">63</a>]. Additionally, the authors use signed integer arithmetic, which optimizes the number of add operations in both sampling and polynomial multiplication.</p> 
     </section> 
     <section id="sec-40"> 
      <p> <em> <strong>Hardware Implementation</strong>.</em> Howe et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0031">31</a>] propose the only hardware implementation of a standard lattice-based encryption scheme based on the LWE problem. These authors perform Multiply-Accumulate (MAC) operations of matrices in the encryption scheme by utilizing a dedicated DSP48A1 unit of the Spartan-6 FPGA to achieve an area-optimized hardware implementation of the standard LWE-based encryption engine.</p> 
      <p>P&ouml;ppelmann et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0078">78</a>] propose the first hardware optimization of polynomial multiplication (NTT) for ideal lattice-based encryption schemes on a Xilinx Spartan-6 FPGA with the primary goal of minimizing the area. The authors design a sequential NTT (one butterfly operator) that stores twiddle factors in a dedicated ROM, which imposes memory overhead but achieves decent performance. An optimized version of the presented NTT polynomial multiplier is employed [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0079">79</a>] for use in a Ring-LWE encryption engine. With acceptable runtime, Aysu et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0037">37</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0159">159</a>] present an optimized hardware implementation of the NTT introduced in P&ouml;ppelmann et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0078">78</a>] to compute polynomial multiplication in a Ring-LWE on the smallest Spartan-3. The main idea is to compute twiddle factors on demand instead of storing them in the ROM. By replacing the modulus with a Fermat number, a shift operation can be used instead of polynomial exponentiation. However, the proposed optimizations cannot take advantage of the inherent parallelism in NTT. It should be mentioned that the authors [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0159">159</a>] do not provide the implementation of the whole crypto-engine.</p> 
      <p>Chen et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0160">160</a>] present a high-performance polynomial multiplication for Ring-LWE encryption cryptosystems in hardware on a Spartan-6 FPGA by exploiting the parallel property of the NTT. The authors provide a different secure set of parameters by which efficient Ring-LWE encryption is achieved. They prove that polynomial multiplication can be done by computing the negative wrapped convolution; thus there is no need to compute the modular reduction. To be more specific, the proposed architecture for polynomial multiplication consists of two butterflies and two point-wise modulo p multipliers (<span class="inline-equation"><span class="tex">$p$</span></span> has the adjustable length) which produce outputs (equivalent to two parallel NTT) that can be used to perform inverse-FFT.</p> 
      <p>Du et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0161">161</a>] propose a scalable and efficient polynomial multiplier architecture, implemented on the Xilinx Spartan-6 FPGA, that takes advantage of NTT's parallelism and provides a speed and area tradeoff. In several works ([<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0078">78</a>] and [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0037">37</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0159">159</a>]), one and two butterfly operators are employed, respectively; however, Du and Bai [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0161">161</a>] use <span class="inline-equation"><span class="tex">$b$</span></span> (power of 2) butterfly operators to improve the speed of the polynomial multiplier, which performs multiplication of two <span class="inline-equation"><span class="tex">$n$</span></span>-degree polynomials in (1.5<span class="inline-equation"><span class="tex">$n$</span></span> + 1.5<span class="inline-equation"><span class="tex">$n$</span></span>log<span class="inline-equation"><span class="tex">$n$</span></span>)/<span class="inline-equation"><span class="tex">$b$</span></span> cycles. To minimize the area, authors employ the cancellation lemma to minimize the number of constant factors. The butterfly operation takes two coefficients (<span class="inline-equation"><span class="tex">$x,y$</span></span>) and one constant factor (<span class="inline-equation"><span class="tex">$\omega$</span></span>) and makes two new coefficients ([<span class="inline-equation"><span class="tex">$x$</span></span>+<span class="inline-equation"><span class="tex">$\omega$</span></span> <span class="inline-equation"><span class="tex">$y$</span></span>] mod <span class="inline-equation"><span class="tex">$p$</span></span>, [<span class="inline-equation"><span class="tex">$x$</span></span>-<span class="inline-equation"><span class="tex">$\omega$</span></span> <span class="inline-equation"><span class="tex">$y$</span></span>] mod <span class="inline-equation"><span class="tex">$p$</span></span>). The butterfly can be used as a modulo <span class="inline-equation"><span class="tex">$p$</span></span> multiplier (by setting <span class="inline-equation"><span class="tex">$x=0$</span></span>). In the first stage of the inverse NTT, the constant factor (<span class="inline-equation"><span class="tex">$\omega$</span></span>) is one, new coefficients are <em>[<span class="inline-equation"><span class="tex">$x$</span></span>-<span class="inline-equation"><span class="tex">$y$</span></span>] mod <span class="inline-equation"><span class="tex">$p$</span></span> </em> and <em>[<span class="inline-equation"><span class="tex">$x$</span></span>+<span class="inline-equation"><span class="tex">$y$</span></span>] mod <span class="inline-equation"><span class="tex">$p$</span></span> </em>. Consequently, necessary clock cycles to calculate a sequential polynomial multiplication are (1.5<span class="inline-equation"><span class="tex">$n$</span></span> + 1.5<span class="inline-equation"><span class="tex">$n$</span></span>log<span class="inline-equation"><span class="tex">$n$</span></span>), which reduces 3.5<span class="inline-equation"><span class="tex">$n$</span></span> of required cycles.</p> 
      <p>Gy&ouml;rfi et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0162">162</a>] perform a thorough evaluation of various candidates to implement modular FFT on Xilinx Kintex-7 FPGA. The authors study three architectures in the diminished-one number system (computations over <span class="inline-equation"><span class="tex">$Z_{2k+1}$</span></span>) for different parameters in order to meet various factors, such as runtime, throughput, area, and scalability. The first architecture yields the best performance using a pipelined modular butterfly-based FFT. The other two architectures are serially distributed arithmetic-based and nested multiplication, which occupy less area than the butterfly-based FFT.</p> 
      <p>Du et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0163">163</a>] achieve a 30% savings in time and space compared to P&ouml;ppelmann and G&uuml;neysu [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0078">78</a>] on a Spartan-6 FPGA by performing an on-the-fly bit-reversal step along with a new memory access scheme, (to load/store coefficients in calculating NTT). The idea is to load/store at address bit-reverse(<span class="inline-equation"><span class="tex">$i$</span></span>) instead of load/store at address <span class="inline-equation"><span class="tex">$i$</span></span> in memory, which means <span class="inline-equation"><span class="tex">$i$</span></span>th coefficient of NTT's output is located in the <em>bit-reverse(i)</em> <span class="inline-equation"><span class="tex">$^{th}$</span></span> memory location. Consequently, the bit-reversal step in the inverse-NTT is eliminated. The authors employ two Block RAMs on FPGA, which provide interleaving; hence, two parallel NTTs can be interleaved. They apply their optimization to the NTT of an RLWE-based public key cryptosystem [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0164">164</a>]. Also, it is assumed that the uniformly random polynomial in the public key scheme is fixed, hence precomputing the NTT offline improves performance. In both papers, only one butterfly operator is used; however, by adapting bit-reversal and memory saving methods, the authors propose a fast polynomial multiplication architecture with four butterfly operators that achieve, on average, a 2.2 speedup improvement [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0165">165</a>]. Two butterfly operators are used to calculate the <span class="inline-equation"><span class="tex">$i$</span></span>th level, and other two perform <span class="inline-equation"><span class="tex">$(i+1)$</span></span>th level calculations in the pipeline using results of the <span class="inline-equation"><span class="tex">$i$</span></span>th stage.</p> 
     </section> 
    </section> 
    <section id="sec-41"> 
     <header> 
      <div class="title-info"> 
       <h3> <span class="section-number">3.2</span> Software Implementations of Lattice-Based Cryptographic Schemes</h3> 
      </div> 
     </header> 
     <section id="sec-42"> 
      <p> <span class="section-number">3.2.1</span> <em>Public Key Encryption.</em> de Clercq et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0084">84</a>] propose an efficient software implementation of Ring-LWE-based encryption for the ARM Cortex-M4F micro-controller. The main goal was maximizing the speed (using assembly level optimization) and minimizing the memory footprint (by storing two coefficients in one word). They employ the Knuth-Yao algorithm to achieve fast noise sampling and use the platform's True Random Number Generator (<span style="font-family:monospace">TRNG</span>) to generate random numbers. They employ optimization [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0037">37</a>], including instruction-level parallelization. Additionally, polynomial multiplication is optimized by integrating multiple coefficients into one large word, allowing load/store operations to be performed with a single instruction.</p> 
      <p>Liu et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0134">134</a>] employ a byte-wise scanning method to improve the performance of a Gaussian sampler based on the Knuth-Yao algorithm, which allows them to implement a Ring-LWE-based PKE scheme on a resource-constrained 8-bit ATxmega128 AVR processor. By applying sophisticated memory alignments for storing coefficients, about a 20% decrease in memory usage is achieved. For NTT computation, a couple of optimization techniques are employed including approximation-based reduction and negative wrapped convolution.</p> 
      <p>Buchmann et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0136">136</a>] implement a high-performance and lightweight PKE scheme on small 8-bit ATXmega128 and 32-bit Cortex-M0 microcontrollers by replacing the Gaussian noise distribution with a uniform binary error distribution. The main advantage of the scheme over Lindner-Peikert's proposal (<span style="font-family:monospace">LP</span>) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0046">46</a>] is the smaller key and ciphertext size. Regarding speed, it is beaten by the scheme in Liu et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0134">134</a>], with its slightly higher memory footprint. Similarly, the proposed design in P&ouml;ppelmann [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0038">38</a>] uses NTT with precomputed twiddle factors and eliminates the bit reversal step, which results in a twofold performance improvement.</p> 
      <p>Yuan et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0137">137</a>] provide a portable JavaScript implementation of <span style="font-family:monospace">LBC</span> schemes on PC web browsers, Tessel (an embedded system for IoT applications), and Android devices. To compute polynomial multiplication in Ring-LWE schemes, NTT is used, while Karatsuba algorithms [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0023">23</a>] are employed for NTRU schemes. To reduce the execution time, inverse transform sampling is employed in which possible values are precomputed and stored in a LUT.</p> 
      <p>Reparaz et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0135">135</a>] implement a masked Ring-LWE scheme on a Virtex-II FPGA and 32-bit ARM Cortex-M4F which is Differential Power Analysis (DPA) resistant. To be resilient to first-order side-channel attacks, a constant time-masked decoder with high success probability is implemented. The entire computation is done in the masked domain by employing a dedicated masked decoder which imposes considerable time and area overhead compared with an unprotected design.</p> 
      <p>Cheon et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0103">103</a>] exploit the <span style="font-family:monospace">LWR</span> problem [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0018">18</a>] and present <span style="font-family:monospace">Lizard</span> and its ring variant (<span style="font-family:monospace">Ring-Lizard</span>). Discrete Gaussian error distribution is replaced with an efficient rounding process with smaller modulus. Lizard beats NTRU and RSA encryption schemes by factors of 3 and 5, respectively. The main idea behind the Lizard is to eliminate the least significant bits of the ciphertext rather than integrating the message with some error.</p> 
      <p>Cheon et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0104">104</a>] submit <span style="font-family:monospace">Lizard</span> (IND-CPA/CCA PKE and IND-CCA2 KEM) and its ring variant, <span style="font-family:monospace">RLizard</span>, to the NIST PQC standardization call (NIST security categories 1, 3, and 5). Sparse and small-secrets versions of LWE and LWR (RLWE and RLWR) are the security basis of the Lizard (RLizard) IND-CPA PKE. Besides an Intel Xeon CPU, the authors provide performance evaluation on a smartphone (Samsung Galaxy S7) for their recommended parameter of Lizard.CPA (128-bit quantum security). They claim that Lizard is suitable for smartphones (memory usage of 20 megabytes). The authors provide datapath and finite state machines for hardware implementation of the Lizard PKE using Lizard.CPA and RLizard.CPA.</p> 
      <p>Chen et al. propose <span style="font-family:monospace">NTRUEncrypt</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0075">75</a>] (NIST standardization call), a family of IND-CCA2 (resistant to subfield attacks) PKE and KEM schemes at 85-, 159-, and 198-bit post quantum security (NIST security categories 1, 5, and 5, respectively). Based on the original NTRU scheme [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0089">89</a>] and using parameters set by Hoffstein et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0105">105</a>], <span style="font-family:monospace">ntru-pke</span> and <span style="font-family:monospace">ntru-kem</span> are achieved by applying NAEP transformation [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0166">166</a>]. Using the same transformation, based on the provably secure NTRU encryption scheme [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0090">90</a>], <span style="font-family:monospace">ss-ntru-pke</span> and <span style="font-family:monospace">ss-ntru-pke</span> are derived. Modulus is set at a power of 2 (<span class="inline-equation"><span class="tex">$2^{11}$</span></span>) to enhance the efficiency of the modulo arithmetic and integer multiplications. The authors adapt a PRNG from Salsa20 [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0167">167</a>] to expand the seed. Box-Muller [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0073">73</a>] is employed (only in ss-ntru-pke and ss-ntru-kem) to sample from the discrete Gaussian distribution. The performance results are reported only for an Intel i7-6600U processor (AVX2 optimization for NTT is not performed).</p> 
      <p>Bernstein et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0128">128</a>] introduce two ideal lattice-based KEMs named <span style="font-family:monospace">Streamlined-NTRU-Prime</span> and <span style="font-family:monospace">NTRU-LPRime</span> with 248-bit and 225-bit security (NIST security category 5), respectively, with ciphertext and key size of around 1kB; these are designed to reduce an attacker's success probability by eliminating ring homomorphisms. Schemes are IND-CCA2, where a key can be used multiple times; hence, large key generation latency is tolerable. The authors implement the reference code on an Intel Xeon. <span style="font-family:monospace">Streamlined-NTRU-Prime</span> is faster than <span style="font-family:monospace">NTRU-LPRime</span> in terms of the encapsulation and decapsulation time with slower key generation.</p> 
      <p>H&uuml;lsing et al. propose <span style="font-family:monospace">NTRU-HRSS</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0127">127</a>], a one-way CPA secure (OW-CPA) PKE, and <span style="font-family:monospace">NTRU-HRSS-KEM</span>, a CCA2-secure KEM derived from NTRU [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0089">89</a>] with 123-bit post-quantum security (NIST security category 1). In contrast to <span style="font-family:monospace">NTRUEncrypt</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0075">75</a>] and standard NTRU [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0168">168</a>], KEM is derived directly from NTRU-HRSS without using padding techniques (e.g., [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0166">166</a>]). Contrary to Streamlined NTRUPrime [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0115">115</a>] and standard NTRU, the correctness of NTRU-HRSS does not rely on the fixed weight distinctions. NTRU-HRSS is designed based on the worrisome algebraic structure of cyclotomic rings (in contrast to Streamlined NTRUPrime). Additionally, NTRU-HRSS has probabilistic encryption, while Streamlined NTRUPrime has deterministic encryption. NTRU-HRSS uses the power of 2 modulus rather than the prime modulus (used in Streamlined NTRUPrime), which leads to faster arithmetic computation. NTRU-HRSS employs trinary secret key/message and large modulus in order to avoid decryption failure (in contrast to LWE-based schemes with a non-zero probability of failure), which leads to lower security and higher communication cost. The authors report the performance results of the reference and AVX2 implementation on an Intel Core i7-4770K CPU.</p> 
      <p>Bansarkhani proposes <span style="font-family:monospace">KINDI</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0129">129</a>] (at NIST PQC standardization call), a trapdoor-based encryption scheme based on LARA [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0169">169</a>], in which data are concealed in the error without changing the target distribution. Consequently, more data are encrypted per ciphertext bit, which reduces the message expansion factor (beneficial in “sign-then-encrypt”). <span class="inline-equation"><span class="tex">${\tt KINDI_{CPA}}$</span></span> (Module-LWE based IND-CPA PKE) has been proposed with five different parameter sets ranging from 164- to 330-bit security (NIST security categories 2, 4, and 5). By applying a variant of Fujisaki-Okamoto (<span style="font-family:monospace">FO</span>) transformation [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0100">100</a>] on the <span class="inline-equation"><span class="tex">${\tt KINDI_{CPA}}$</span></span>, <span class="inline-equation"><span class="tex">${\tt KINDI_{CCA-KEM}}$</span></span> with the same parameter space can be built.</p> 
     </section> 
     <section id="sec-43"> 
      <p> <span class="section-number">3.2.2</span> <em>Key Exchange.</em> Ding et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0097">97</a>] propose a provably secure Ring-LWE key exchange mechanism which is not passively secure since it produces biased keys. Peikert improves the protocol by using a new reconciliation method which generates unbiased keys [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0170">170</a>]. Bos et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0098">98</a>] propose a practical constant-time software implementation of the Peikert's Ring-LWE key exchange protocol, namely BCNS, which can be added as the key exchange protocol to the transport layer security (<span style="font-family:monospace">TLS</span>) protocol in OpenSSL along with RSA as the authentication and SHA-256 as the hashing method. The most time-consuming part of the protocol is the Gaussian sampler, which is done by employing a constant-time search on the Cumulative Distribution Table (<span style="font-family:monospace">CDT</span>). The authors adapt the FFT from Nussbaumer's method [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0026">26</a>] for polynomial arithmetic in cyclotomic rings whose degree is a power of 2 that provides efficient modular reduction. BCNS employs a fixed polynomial as the system parameter, which can be a potential weak link of the protocol. Selection of a large modulus results in lower efficiency and security level (78-bit quantum security) than expected from a Ring-LWE scheme. In contrast to the digital signature and encryption schemes, the key exchange scheme does not need a high-quality Gaussian sampler [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>], which BCNS uses; consequently, a simpler noise distribution is used in NewHope instead of a Gaussian sampler. BCNS caches keys, which can be very dangerous to the security of the protocol because of shared-key reused attacks [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0171">171</a>], a problem that is solved in NewHope.</p> 
      <p>Alkim et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>] introduce NewHope, a portable C and highly optimized SIMD implementation (AVX2) of an unauthenticated key exchange scheme, that solves the inefficiency (10 times better performance) and security drawbacks (increase quantum security level from 78-bit to 128-bit) of BCNS by optimizing the key exchange algorithm and better parameter selection. A better analysis of failure probability which results in a smaller modulus, on-the-fly generation of the polynomial system parameter, efficient polynomial arithmetic (combining Montgomery and Barret reduction and employing polynomial encoding), and use of the centered binomial instead of the discrete Gaussian distribution are the main improvements of NewHope over BCNS. NewHope has attracted the attention of research and industry communities such that Google released the Chrome Canary, which uses NewHope as the key exchange protocol along with elliptic curve Diffie–Hellman as the authentication protocol [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0172">172</a>].</p> 
      <p>Alkim et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0062">62</a>] propose <span style="font-family:monospace">NewHope-Simple</span>, a simpler variant of NewHope with the same performance and security level. Simplicity is achieved by eliminating the error-reconciliation mechanism [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0097">97</a>] with a 6% message size overhead. The authors discard the least significant bits of each coefficient due to their negligible impact on successful plaintext recovery. Additionally, the authors encode a single-key bit into four coefficients, which results in a reduction of the ciphertext length. In <span style="font-family:monospace">NewHope-Simple</span>, polynomial <span class="inline-equation"><span class="tex">$a$</span></span> can be fixed, while the original <span style="font-family:monospace">NewHope</span> generates <span class="inline-equation"><span class="tex">$a$</span></span> on the fly for every single run of the scheme. Alkim et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0063">63</a>] present the software implementation of NewHope on the ARM Cortex-M family, low-power Cortex-M0 and high-performance Cortex-M4, which is the first key exchange scheme with a quantum security level of 128 bits on constrained embedded devices. The authors optimize all hot regions of the protocol in assembly, including error reconciliation, the uniform noise generation by ChaCha20 stream cipher [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0173">173</a>], and NTT/NTT<span class="inline-equation"><span class="tex">$^{-1}$</span></span>. For NTT, the authors set a memory-time tradeoff for precomputing the powers of constants (design parameters) by which only a subset of the powers of constants are precomputed and stored in the table. Gueron and Schlieker [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0143">143</a>] further optimize NewHope by optimizing the pseudorandom generation part, which results in 1.5<span class="inline-equation"><span class="tex">$\times$</span></span> better performance on the Intel Skylake processors. The authors improve the sampling step by lowering the rejection rate (from 25% to 6%) and exploit the parallelism in the pseudorandom generation (replace SHAKE-128 with the parallelized SHA-256 or AES block cipher) and rejection sampling (employing AVX vector instructions). Longa and Naehrig [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0158">158</a>], employ a reduction technique (during the NTT calculation) that eliminates the modular reduction after the additions of two polynomials, which results in speed improvements of 1.9 and 1.25 for C and AVX implementations (compared to the reference NewHope [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>]), respectively.</p> 
      <p>Adapted from NewHope-Simple, Alkim et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0065">65</a>] propose NewHope as a family of KEMs at NIST PQC standardization call. The submitted proposal includes NewHope512-CPA-KEM and NewHope512-CCA-KEM (<span class="inline-equation"><span class="tex">$n=1024, q=12289$</span></span>) which targets 101-bit security (NIST security category level 1) and NewHope1024-CPA-KEM and NewHope1024-CCA-KEM with 233-bit security (NIST category security category 5), with performance comparable to the elliptic curve-based cryptosystems. The four mentioned KEMs are derived from NewHope-CPA-PKE (which does not support arbitrary length messages and thus cannot be used as a standalone encryption scheme) by applying a variant of the FO transform [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0100">100</a>]. In order to generate the random number and shared secret, hash function <span style="font-family:monospace">SHAKE256</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0174">174</a>] is used as a pseudorandom function; generation of the shared polynomial <span class="inline-equation"><span class="tex">$a$</span></span> is done by expanding a 32-byte seed using <span style="font-family:monospace">SHAKE128</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0174">174</a>]. Besides the reference and vectorized (using AVX instructions) implementations on the Intel Core i7-4770K (Haswell) processor, the authors provide implementation and optimization of KEMs on a 64-bit MIPS architecture (MIPS64).</p> 
      <p>Ding et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0126">126</a>] propose (at NIST PQC standardization call) <em>Ding Key Exchange</em>, an ephemeral IND-CPA secure error reconciliation-based key exchange protocol from the RLWE problem. At the same security level, Ding Key Exchange reduces communication cost (due to its rounding technique) compared to similar schemes (NewHope, NewHope-Simple, and Kyber). It provides security equivalent to AES-128, AES-192, and AES-256 (NIST security categories 1, 3, and 5) with flexible parameter choices and a key size of <span class="inline-equation"><span class="tex">$n$</span></span>-bit where <span class="inline-equation"><span class="tex">$n$</span></span> can be 512 and 1024; as a result, it is more resistant to the Grover algorithm compared to NewHope, NewHope-Simple, and Kyber with their key size of 256 bits. The NTL library [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0154">154</a>] and CDT sampler are used for polynomial multiplication and sampling from the Gaussian distribution.</p> 
      <p> <span style="font-family:monospace">HILA5</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0117">117</a>], a Ring-LWE-based KEX (and also PKE) with the same security parameters (<span class="inline-equation"><span class="tex">$n=1024, q=12289$</span></span>) and sampler (binomial sampler <span class="inline-equation"><span class="tex">$\psi _{16}$</span></span>) as NewHope, has been tested on an Intel Core i7-6700 CPU and is integrated into OQS and OpenSSL. HILA5 uses SafeBits, an improved version of the Peikert reconciliation mechanism [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0170">170</a>], to reach slightly smaller messages than NewHope (36-byte, which is 0.9%) at the same security level by generating unbiased secret bits and hence less randomness in secret bits. HILA5 employs an efficient constant time error correction block to correct 5 bits of error, which results in a decryption failure of <span class="inline-equation"><span class="tex">$2^{-128}$</span></span> compared to NewHope's failure rate of <span class="inline-equation"><span class="tex">$2^{-64}$</span></span> (Frodo [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0032">32</a>] and Kyber [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0041">41</a>] report failure rates of <span class="inline-equation"><span class="tex">$2^{-38.9}$</span></span> and <span class="inline-equation"><span class="tex">$2^{-71.9}$</span></span>, respectively) while sacrificing less than 4% of performance. HILA5 can be employed as a PKE scheme due to its higher reliability. <span style="font-family:monospace">HILA5</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0066">66</a>] is submitted to the NIST PQC standardization call as a famility of PKE and KEM schemes that provide security equivalent to AES-256 (NIST security category 5). Optimized polynomial multiplication and error sampling are performed by employing the Cooley-Tukey [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0027">27</a>] method and binomial distribution. In addition, SHAKE-256 is used to sample from the uniform distribution.</p> 
      <p> <span style="font-family:monospace">Frodo (FrodoCCS)</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0032">32</a>], the first practical implementation of a PKE scheme based on standard lattices, the original LWE problem [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0007">7</a>], is secure against cache-timing attacks. Like BCNS, Frodo can be integrated into OpenSSL such that Google has announced that Frodo is used in 1% of Chrome web browsers. Matrix arithmetic compared to polynomial arithmetic imposes considerable overheads on the bandwidth (4.7x more than NewHope), throughput (1.2 less throughput than NewHope), and performance (8x slower than NewHope). Massive memory overhead is imposed if a matrix variant should be saved in memory. By generating and afterward discarding the matrix variant (on-the-fly), memory overhead is alleviated. The authors use an efficient inversion sampling method that uses precomputed tables. Based on the authors’ claim, integration of Frodo into TLS halves server throughput. Consequently, NTT-friendly primes and polynomials are not crucial, which results in a negligible drop in performance compared to NewHope [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>].</p> 
      <p> <span style="font-family:monospace">FrodoKEM</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0107">107</a>] is a family of IND-CCA secure KEMs based on the LWE problem with brute-force security of at least AES-128 (FrodoKEM-640) and AES-192 (FrodoKEM-640). FrodoPKE is transformed by a variant of the <span style="font-family:monospace">FO</span> transformation [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0100">100</a>] to build FrodoKEM. The authors generate a public matrix <span class="inline-equation"><span class="tex">$A$</span></span> from a small seed using PRNG (AES128 or cSHAKE128) which results in a more balanced ciphertext and key sizes, but remarkable computational overhead. Timing and cache attacks are prevented by prohibiting the use of secret address accesses and branches. A portable C code reference and its optimized implementation (generating the public matrix <span class="inline-equation"><span class="tex">$A$</span></span> and matrix arithmetic) are provided. The authors report the results of the implementation on a 64-bit ARM Cortex-A72 (with the best performance achieved by using an OpenSSL AES implementation that benefits from the NEON engine) and an Intel Core i7-6700 (x64 implementation using AVX2 and AES-NI instructions). Employing modular arithmetic (<span class="inline-equation"><span class="tex">$q \le 2^{16}$</span></span>) results in efficient and easy to implement single-precision arithmetic. The sampling of the error term (16 bits per sample) is done by inversion sampling using a small LUT that corresponds to the discrete cumulative density functions (CDT sampling).</p> 
      <p>Open Quantum Safe (<span style="font-family:monospace">OQS</span>) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0175">175</a>] software platform is designed to evaluate quantum-resistant schemes which have an open-source library (contains a C implementation of BCNS, NewHope, Frodo, etc.) of <span style="font-family:monospace">PQC</span> schemes. OQS offers the chance to integrate the quantum-resistant schemes into classical applications and protocols with the goal of minimizing software change; in addition, OQS provide the opportunity to compare <span style="font-family:monospace">PQC</span> schemes with each other or with classical cryptographic schemes.</p> 
      <p>Jin et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0113">113</a>] present symmetric (OKCN) and asymmetric (AKCN) LWE and Ring-LWE based key exchange mechanisms. OKCN, optimally balanced key consensus with noise, can be used for key transport and encryption, while AKCN, asymmetric key consensus with noise, can only be employed for key transport. In the proposed scheme, the server sets the session key before starting the key exchange mechanism. Consequently, it provides the opportunity for offline message encryption, which provides higher security and better workload balance. Compared with Frodo, OKCN-LWE produces a much smaller matrix by eliminating the least significant bits of each LWE sample, which results in less computation for matrix arithmetic; the smaller matrix also results in the faster generation and sampling of the matrix. With the same set of parameters, OKCN-LWE consumes more bandwidth (30%) than Frodo, while its failure probability is remarkably lower. Employing the same optimization techniques, a Ring-LWE-based version of OKCN, which adapts the same noise distribution and parameters as NewHope, provides a more computationally efficient scheme than NewHope. The authors integrate the OKCN-LWE scheme into the open safe project platform [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0175">175</a>].</p> 
      <p>Zhao et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0114">114</a>] extend [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0113">113</a>] and present a generic construction of the authenticated key exchange, PKE, and KEM schemes based on LWE/RLWE, LWR, and MLWE problems (submitted to NIST PQC standardization call as <span style="font-family:monospace">KCL</span> (pka OKCN/AKCN/CNKE)). OKCN-LWE and OKCN-LWR key exchange mechanism require less bandwidth (18% and 28%) compared to Frodo at the same security level (shared key size of 256 bits). The most efficient KEX with the shared key size of 512 bits is achieved by AKCN. The authors prove that the errors in different positions in the shared key are independent and propose Single-Error Correction (SEC) code to correct at least one bit error; using the SEC, with the same security and error rate, OKCN/AKCN-RLWE-based KEX schemes generate a 765-bit shared key with less bandwidth than NewHope and NewHope-Simple (with a 256-bit shared key). The authors claim that they provide the most efficient lattice-based KEX with a shared key size of 256 bits by applying OKCN/AKCN to the MLWE-based key KEX. Additionally, they provide a new authenticated key exchange scheme named Concealed Nonmalleable Key-Exchange (CNKE).</p> 
      <p>Seo et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0106">106</a>] propose an error-blocked multibit key encapsulation mechanism named EMBLEM and (R.EMBLEM) which is secure against adaptive chosen-ciphertext attack based on the small secret LWE (RLWE) problem. During the decryption phase, the error does not affect the message; this is achieved by separating the message and error and concatenating each message block with the error-blocking bit. The secret key is sampled uniformly at random in <span class="inline-equation"><span class="tex">$[-B, B]$</span></span> (where <span class="inline-equation"><span class="tex">$B$</span></span> is a positive integer smaller than <span class="inline-equation"><span class="tex">$\sigma$</span></span>) instead of using Gaussian distribution. Consequently, the key size is notably reduced since the secret key can be generated by a 256-bit seed, which eliminates the need for storing the whole matrix; however, it imposes computational overhead to generate the secret key from the seed using pseudorandom functions. For polynomial multiplication in R.EMBLEM, Cooly-Tukey butterfly and Gentleman-Sande butterfly are used in NTT and inverse NTT, respectively. Besides the software implementation on an Intel core-i7-7600, the authors implement schemes on the Zynq 7 FPGA platform.</p> 
      <p> <span style="font-family:monospace">Kyber</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0041">41</a>] is a highly optimized IND-CCA KEM with post-quantum security based on the hardness of solving the (<span style="font-family:monospace">Modulue-LWE</span>) problem [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0019">19</a>]. Ideal lattices, with their ring structure, decrease the public key and ciphertext size of standard lattices schemes by sacrificing security assumptions. Module lattices are proposed to fill the gap, believing that a full ring structure is excessive [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0019">19</a>]. The authors define an IND-CPA PKE scheme under the Module-LWE hardness assumption and apply a variant of the FO transform [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0100">100</a>] to build an IND-CCA KEM. Employing IND-CCA KEM, they design IND-CCA KEX and AKEX under a hardness assumption in the classical and quantum random-oracle models. Kyber works over only one ring, <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/760f4c70-a477-4111-9bd6-d05bd2379b0e/csur5106-129-inline567.gif" class="img-responsive" alt="" longdesc="" /></span>, which provides flexibility (e.g., performing polynomial multiplication) at the sacrifice of security (from 128-bit to 102-bit) to improve performance and communication size (33%) (by only changing <span class="inline-equation"><span class="tex">$k$</span></span> from 3 to 2). This flexibility is exclusive to Kyber (Module-LWE schemes); in Ring-LWE schemes, changing the security parameters results in building a new ring <span class="inline-equation"><span class="tex">$R_q$</span></span> and ring operations. Kyber has been submitted to the NIST PQC standardization call as Kyber512, Kyber768, and Kyber1024 at 102-, 161-, and 218-bit security (NIST security categories 1, 3, and 5) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0069">69</a>].</p> 
      <p>Lu et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0067">67</a>] present <span style="font-family:monospace">LAC</span> (<strong>LA</strong>ttice-based <strong>C</strong>ryptosystems) that includes an IND-CPA PKE (<span style="font-family:monospace">LAC.CPA</span>), a passively secure KEX (<span style="font-family:monospace">LAC.KE</span>), an IND-CCA KEM (<span style="font-family:monospace">LAC.CCA</span>), and an AKEX (<span style="font-family:monospace">LAC.AKE</span>) all of which are based on the RLWE problem. The main design concern is to enhance bandwidth efficiency (reduce key and ciphertext size) by setting modulus <span class="inline-equation"><span class="tex">$q$</span></span> to be small (<span class="inline-equation"><span class="tex">$q=251$</span></span>), which prevents the direct use of NTT in LAC. Although employing AVX2 vector instructions improves the performance of the polynomial multiplication by a factor of 30, polynomial multiplication imposes remarkable computational pressure on the systems without the support of vector instructions. Sampling the secret and error term is done by employing the centered binomial distributions. LAC is proposed with three set of parameters that are much more expensive to break than AES128, AES192, and AES-256 (NIST security categories 1, 3, and 5).</p> 
      <p>Smart et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0068">68</a>] propose <span style="font-family:monospace">LIMA</span> (<strong>L</strong>att<strong>I</strong>ce <strong>MA</strong>thematics), a family of IND-CCA and IND-CPA RLWE-based PKE (based on <span style="font-family:monospace">LP</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0046">46</a>]) and KEM schemes, to the NIST PQC standardization call as a set of parameters with claimed post-quantum security from 143 to 274 (NIST security categories 1, 2, 3, and 5). The authors employ the FO and Dent transforms [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0176">176</a>] to obtain IND-CCA PKE and IND-CCA KEM schemes. In addition to power-of-2 cyclotomic rings (<span style="font-family:monospace">LIMA-2p</span>), the authors propose safe-prime cyclotomics (<span style="font-family:monospace">LIMA-sp</span>) that reduce the probability of subfield attacks by sacrificing efficiency compared to the power-of-2 cyclotomics. In order to avoid decryption failure, the authors perform rejection sampling (from a centered binomial distribution) at the encryption stage, which makes the implementation in non-constant time. To perform the polynomial multiplication with FFT, a large modulus should be selected for <span style="font-family:monospace">LIMA-sp</span>.</p> 
      <p>Phong et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0102">102</a>] present <span style="font-family:monospace">LOTUS</span> (<strong>L</strong>earning with err<strong>O</strong>rs based encryption with chosen ciphertex<strong>T</strong> for po<strong>S</strong>t quantum era), an IND-CCA2 secure LWE-based PKE (<span style="font-family:monospace">LOTUS-PKE</span>) and KEM (<span style="font-family:monospace">LOTUS-KEM</span>) with 128-bit, 192-bit, and 256-bit security (NIST security categories 1, 3, and 5). The Knuth-Yao algorithm [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0083">83</a>] is employed to sample the error term from the discrete Gaussian distribution. In order to reduce the sampling's overhead, a DDG tree is built online and a probability matrix is stored column-wise. In addition to the reference and optimized implementations, vectorized implementations (employing AVX2 vector instructions) of LOTUS-PKE and LOTUS-KEM are provided.</p> 
      <p> <span style="font-family:monospace">NTRU-KEM</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0125">125</a>], an IND-CCA2-secure KEM based on the NTRU cryptosystem with 128-bit classical security, is the first timing attack-resistant NTRU software thanks to its constant-time noise sampler. NTRU-based KEM has active security, which allows parties to cache the ephemeral keys; however, passive secure key exchange mechanisms like NewHope and Kyber should not use cached values. Compared to NewHope (255-bit PQ security), NTRU-KEM (123-bit PQ security) improves secret key size, public key size, and ciphertext size by <span class="inline-equation"><span class="tex">$20\%,37\%, 37\%$</span></span>, respectively, and halves the required clock cycles for the encryption/encapsulation step. However, it increases required clock cycles for key generation and decryption/encapsulation by a factor of 3.47.</p> 
      <p>Plantard [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0108">108</a>] presents <span style="font-family:monospace">Odd-Manhattan</span>, an IND-CCA KEM by using the Dent transform on IND-CPA PKE, at 126-, 192-, and 256-bit security (NIST security categories 1, 3, and 5). <span style="font-family:monospace">Odd-Manhattan</span> is based on the <em> <span class="inline-equation"><span class="tex">$\alpha$</span></span>-Bounded Distance Parity Check (BDPC<span class="inline-equation"><span class="tex">$\alpha$</span></span> </em>) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0177">177</a>], which imposes a considerable increase in time and the size of key generation, encryption, and decryption. To mitigate the timing overhead, computational reuse (i.e., store the results of the <span class="inline-equation"><span class="tex">$k$</span></span> consecutive additions (constant time) in memory) with a notable memory penalty has been employed.</p> 
      <p>Garcia-Morchon et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0109">109</a>] introduce <span style="font-family:monospace">Round2</span>, a family of CCA-PKE (<span style="font-family:monospace">Round2.PKE</span>) and CPA-KEM (<span style="font-family:monospace">Round2.KEM</span>) based on the General Learning with Rounding (GLWR) problem. By having <span class="inline-equation"><span class="tex">$d$</span></span> (dimension), <span class="inline-equation"><span class="tex">$n$</span></span> (system parameter), <span class="inline-equation"><span class="tex">$q$</span></span> (large modulus), and <span class="inline-equation"><span class="tex">$p$</span></span> (rounding modulus) <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/dda7c7b6-99e7-4a69-993a-40c4b22faaa6/csur5106-129-inline580.gif" class="img-responsive" alt="" longdesc="" /></span> where <span class="inline-equation"><span class="tex">$q \le p$</span></span> and <span class="inline-equation"><span class="tex">$n \in {1,d}$</span></span>, if <span class="inline-equation"><span class="tex">$n=1$</span></span>, this instantiated scheme is based on the LWR problem, while <span class="inline-equation"><span class="tex">$n=d$</span></span> (<span class="inline-equation"><span class="tex">$n+1$</span></span> is prime) results in a RLWR-based scheme. Round2 provides two sets of parameters including Unified-Round2 (<span style="font-family:monospace">uRound2</span>, <span class="inline-equation"><span class="tex">$q$</span></span> is a power of 2) and NTT-Round2 (<span style="font-family:monospace">nRound2</span>, <span class="inline-equation"><span class="tex">$q$</span></span> is prime, <span class="inline-equation"><span class="tex">$n=d$</span></span> (<span class="inline-equation"><span class="tex">$n+1$</span></span> is prime)). With uRound2, schemes can be seamlessly instantiated from LWR or RLWR [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0018">18</a>] (for all NIST security levels), both <span class="inline-equation"><span class="tex">$n=1$</span></span> and <span class="inline-equation"><span class="tex">$n=d$</span></span>, with the same code, which provides agility (i.e., switching from RLWR-based schemes to LWR-based schemes without recompilation). GLWR, compared to LWE, results in less random data generation due to avoiding sampling from nonuniform noise distribution; in addition, the required bandwidth is reduced since fewer bits are needed per coefficient. Secret terms can be either sparse-trinary (reduces the probability of error in decryption) or uniformly sampled in <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/80dc2e61-6076-4e13-a8f6-01ab4eaa62fc/csur5106-129-inline592.gif" class="img-responsive" alt="" longdesc="" /></span>. In order to have a unique implementation for LWR and RLWR, a common multiplier that implements polynomial multiplication as the matrix multiplication is employed. Compare to NewHope [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>] and Kyber [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0041">41</a>], RLWR-based uRound2 requires smaller public-key and ciphertext in total for NIST security category 5. Over the same ring as the NTRU-KEM scheme, Round2 shows a better speedup due to its faster key generation. Performance evaluation of the reference implementation is performed on Intel Core i7 2.6GHz.</p> 
      <p>D'Anvers et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0130">130</a>] propose <span style="font-family:monospace">SABER</span>, a family of Module-LWR-based IND-CPA PKE and IND-CCA KEM schemes including <span style="font-family:monospace">LightSaber-KEM</span>, <span style="font-family:monospace">Saber-KEM,</span> and <span style="font-family:monospace">FireSaber-KEM</span> with 115-, 180-. and 245-bit security (NIST security categories 1, 3, and 5). Integers are chosen to be the power-of-2 modulus, which results in avoiding explicit modular reduction and relaxing complicated sampling methods (e.g., rejection) by efficient constant time sampling from a (modulo power 2) uniform distribution; however, a power-of-2 modulus prevents using NTT for polynomial multiplication (Karatsuba and Toom-Cook algorithms are used instead). Switching among SABER schemes is accomplished by choosing a modulus of higher rank in the fixed polynomial ring <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/df8ce6dd-2f08-4698-94d0-62ae08152218/csur5106-129-inline593.gif" class="img-responsive" alt="" longdesc="" /></span>. The failure rate is reduced by using a reconciliation method introduced in Alkim et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0062">62</a>].</p> 
      <p>Hamburg [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0091">91</a>] introduces<em> <span style="font-variant:small-caps">ThreeBears</span> </em>, a family of IND-CPA and IND-CCA KEM schemes adapted from Kyber [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0041">41</a>] and based on the integer Module-LWE (<span style="font-family:monospace">ILWE</span>) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0178">178</a>] problem. <em> <span style="font-variant:small-caps">ThreeBears</span> </em> includes <em> <span style="font-variant:small-caps">BabyBear</span> </em>, <em> <span style="font-variant:small-caps">MamaBear</span> </em> (recommended), and <em> <span style="font-variant:small-caps">PapaBear</span> </em> with NIST security categories 2, 4, and 5, respectively. For each scheme, deterministic CCA-secure (with <span style="font-family:monospace">FO</span> transform) and ephemeral (without <span style="font-family:monospace">FO</span> transform) implementations are presented. To reduce the memory footprint, the private key is rapidly generated by expanding a seed; similarly, the public key and large public matrix are generated in modulus <span class="inline-equation"><span class="tex">$N,$</span></span> where <span class="inline-equation"><span class="tex">$N$</span></span> is a large Mersenne prime. Sampling the noise is performed by expanding a seed to only 1B per digit. Although Saarinen's error correction [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0116">116</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0117">117</a>] can notably improve <em> <span style="font-variant:small-caps">ThreeBears</span> </em> security, the author prefers to use a Melas BCH code as the two-error-correcting code to maintain the code simplicity. To preserve simplicity, NTT is not used, which results in slower integer arithmetic, particlularly on devices without vector unit support. Performance analysis of the <em> <span style="font-variant:small-caps">ThreeBears</span> </em> implementations are provided on Intel Skylake, ARM Cortex-A8, and ARM Cortex-A53. With 15% smaller ciphertext and public key size, <em> <span style="font-variant:small-caps">MamaBear</span> </em> (respectively, <em> <span style="font-variant:small-caps">PapaBear</span> </em>) is stronger than <em>Kyber-Paranoid</em> (respectively, Hila5 [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0116">116</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0117">117</a>] and NewHope [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>]).</p> 
      <p>Steinfeld et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0070">70</a>] present <span style="font-family:monospace">Titanium</span>, a family of IND-CPA PKE (<span style="font-family:monospace">Titanium-CPA</span>) and IND-CCA KEM (<span style="font-family:monospace">Titanium-CCA</span>) schemes based on the Middle Product LWE (<span style="font-family:monospace">MPLWE</span>) problem [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0092">92</a>]. Schemes are tightly and provably secure based on the hardness of the Polynomial-LWE problem over the polynomial ring <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/3900a6bc-2de0-4b91-b673-8b937baf9293/csur5106-129-inline596.gif" class="img-responsive" alt="" longdesc="" /></span> where <span class="inline-equation"><span class="tex">$f$</span></span> is the member of a large group of ring polynomials. Titanium is a middle-ground scheme that achieves a tradeoff between security and efficiency such that, in terms of ciphertext size and performance, it is superior to <span class="inline-equation"><span class="tex">$Frodo$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0032">32</a>] but inferior to <span class="inline-equation"><span class="tex">$Kyber$</span></span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0041">41</a>]. Among six suggested parameter sets, <span class="inline-equation"><span class="tex">$Std128$</span></span>, <span class="inline-equation"><span class="tex">$Med160$</span></span>, <span class="inline-equation"><span class="tex">$Hi192,$</span></span> and <span class="inline-equation"><span class="tex">$Super256$</span></span> satisfy minimum security specified by NIST (categories 1, 1, 3, and 5, respectively). However, the security analysis of Titanium assumes the classical random oracle model. NTT and binomial difference error distribution are used for polynomial multiplication and error sampling; secret key coordinates are sampled uniformly at random over <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/b3a12b1d-7325-41b1-9f4a-17f127bca8e5/csur5106-129-inline604.gif" class="img-responsive" alt="" longdesc="" /></span>. It should be mentioned that error correction or reconciliation techniques are not employed in Titanium. In addition to the reference and optimized implementation, the authors provide performance analysis of avectorized implementation (AVX2) on Intel i7-7700K.</p> 
     </section> 
     <section id="sec-44"> 
      <p> <span class="section-number">3.2.3</span> <em>Digital Signature.</em> Lyubashevsky [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0110">110</a>] presents a Short Integer Solution (<span style="font-family:monospace">SIS</span>) problem-based digital signature scheme adapted from the Fiat-Shamir transformation. Lyubashevsky improves this scheme by establishing it efficiently for Ring-SIS and Ring-LWE, which culminates in a smaller signature and key size [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0118">118</a>]. The BLISS signature [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0033">33</a>] is an optimized version of Lyubashevsky's signature where a binomial Gaussian sampler is used in the rejection sampler component resulting in a remarkable reduction in the standard deviation of the Gaussian distribution. Bai and Galbraith [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0094">94</a>] propose a provably secure small signature (<span style="font-family:monospace">BG</span> signature) based on the standard LWE and SIS problems that can be implemented using uniform distributions. Standard worst-case computational assumptions on lattices are the basis of security for the BG signature scheme.</p> 
      <p>P&ouml;ppelmann et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0038">38</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0141">141</a>] evaluate implementations of various <span style="font-family:monospace">LBC</span> schemes, including RLWE-based PKE schemes and <span style="font-family:monospace">BLISS</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0033">33</a>], on the 8-bit AVR microcontrollers. They review various NTT algorithms (written in C) and optimize (using assembly language and ignoring zero coefficients) polynomial multiplication (column-wise) for ideal <span style="font-family:monospace">LBC</span> schemes. However, using precomputed twiddle factors in NTT computations requires more memory footprint. Official release code of Keccak [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0179">179</a>] for AVR is used for the random oracle, which is needed for signing and verification. Other optimizations offered by the authors are removing the bit reversal step during polynomial multiplication and applying the Gaussian sampling in a lazy manner. Compared to RLWE encryption, BLISS needs a larger standard deviation for sampling from Gaussian distribution; candidates for Gaussian sampling are CDT sampling [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0180">180</a>] with binary search, which results in large tables, and Bernoulli [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0140">140</a>], that imposes a remarkable performance overhead. Consequently, for the Gaussian sampler, a KL-convolution sampler [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0060">60</a>] is used which consumes less flash memory compared with the CDT and Bernoulli samplers. The BLISS implementation consumes the least flash footprint on AVR and has the lowest published runtime by 2015.</p> 
      <p>BLISS-B [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0120">120</a>] (with the same security level) improves the performance of original BLISS by 2.8x by employing the ternary representation of polynomials in order to shorten the length of the random numbers. During key generation, keys are rejected, which leads to a 5-10x reduction in the runtime of the key generation step. Generated signatures by BLISS and BLISS-B are compatible with each other, allowing signatures generated by one to be valid for the other. Although generated keys of BLISS-B cannot be used in BLISS, BLISS-generated keys are compatible with BLISS-B.</p> 
      <p>Oder et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0139">139</a>] present an efficient software implementation of BLISS on the ARM Cortex-M4F to optimize the throughput along with minimizing the memory footprint. The authors evaluate the efficiency of a variety of Gaussian samplers including the Bernoulli, Knuth-Yao, and Ziggurat [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0076">76</a>]. In order to improve NTT computation, assembly-level optimization along with precomputed coefficients are employed. They conclude that the Knuth-Yao sampler is the best candidate for large devices, while for constrained devices Bernoulli is more favorable.</p> 
      <p>G&uuml;neysu et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0138">138</a>] present a highly optimized SIMD implementation of the <span style="font-family:monospace">GLP</span> signature [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0061">61</a>] and implement it on Intel's Sandy and Ivy Bridge processors. In the proposed scheme, the Gaussian sampler is replaced with uniform sampling from <span class="inline-equation"><span class="tex">$\lbrace -1,0,+1\rbrace$</span></span>; to benefit from the <span style="font-family:monospace">AVX</span>, each 512 double-precision floating-point array of coefficients is 32-byte aligned. In addition, modular reduction of the coefficients is performed in a lazy manner. However, the signature size and security level of the implemented scheme are inferior to BLISS.</p> 
      <p>El Bansarkhani and Buchmann [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0119">119</a>] implement the first software implementation (space and speed optimized) of a GPV signature scheme [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0093">93</a>] by employing the Micciancio and Peikert (MP) trapdoors [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0181">181</a>] on the Sun XFire 4400 server equipped with 16 Quad-Core AMD Opteron. Besides the matrix version, a much faster Ring-LWE-based variant of the scheme is provided which has around 3--6&times; and 3--9&times; better speed than the matrix version for the sign and verification steps, respectively. Due to the small number of stored entries, instead of rejection sampling, the inversion transform method is used for discrete Gaussian sampling during integer key generation; however, rejection sampling [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0093">93</a>] is used in the randomized rounding.</p> 
      <p>Dagdelen et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0133">133</a>] propose a fast software implementation of the BG signature, with optimized rejection sampling, on an Intel processor with AVX and an ARMv7 with Neon vector instructions support. Only a small performance degradation is observed by employing the standard lattices instead of ideal lattices, which is a great achievement because there is no quasi-logarithmic arithmetic scheme like NTT for standard lattices.</p> 
      <p>Boorghany et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0140">140</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0180">180</a>] propose an efficient software implantation of lattice-based GLP and BLISS authentication protocols for resource-constrained smart cards and microcontrollers (ARM and AVR). The authors perform a design space exploration by choosing different parameter sets for FFT and the Gaussian sampler (Knuth-Yao and Bernoulli) along with the various PKE schemes. They conclude that <span style="font-family:monospace">LBC</span> schemes are efficient enough to be implemented on constrained devices.</p> 
      <p>Alkim et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0111">111</a>] introduce <span style="font-family:monospace">TESLA</span> (a tightly secure signature in random oracle model) by a tight reduction to LWE-based problems on the standard lattices and implement it on Intel Core-i7 4770K (Haswell). They adapt the design from BG signature [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0094">94</a>] which is faster and smaller than the same scheme in Dagdelen et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0133">133</a>] due to employing parallel matrix-vector multiplication and lazy reduction. The authors propose two variants, TESLA-128 and TESLA-256; the former one, TELSA-I, is not quantum-resistant, while the latter, TELSA-II, provides the first lattice-based digital signature with 128-bit security against quantum computers. A large public key size (about 1 MB) makes it impractical to implement. The same authors present a fast, small, and provably secure Ring-LWE-based software implementation of TESLA that uses uniform sampling on the same platform; this version reduces the key size by about three orders of magnitude [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0142">142</a>]. The proposed Ring-TESLA benefits from AVX2 instructions, which has a one-cycle throughput for eight doubles integers. Instantiation from Ring-TESLA leads to the rejection of valid signatures in the verification stage due to a problem in parameter selection, which is solved in Chopra [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0121">121</a>] by new parameter selection method and in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0051">51</a>] by altering the algorithm. Based on the claims in Barreto et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0051">51</a>], TESLA and Ring-TESLA use global parameters, which results in employing a fixed lattice for all the signatures that could weaken the signature scheme. A recent version of TESLA [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0111">111</a>] fixes the problem by adding a new condition to the signing step, which results in dropping the speedup and creating a more complex signature scheme, with less success in signing. Barreto et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0051">51</a>] introduce TESLA#, a high-performance version of Ring-TESLA, on an Intel Core i7-4770 Haswell processor, which resolves the security problems of TESLA. Further improvement is achieved by designing a more efficient Gaussian, which accelerates the key generation step along with avoiding storage of all 32 bits of coefficients of the polynomial. Bindel et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0124">124</a>] propose qTESLA, a family of)provably, existentially unforgeable under chosen-message attack (<span style="font-family:monospace">EUF-CMA</span>) secure in the quantum random oracle model) Ring-LWE-based digital signature schemes, including qTESLA-128, qTESLA-256, and qTESLA-192 with NIST security categories of 1, 3, and 5, respectively. qTESLA adapts a simpler version [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0051">51</a>] of the bimodal Gaussian sampler [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0033">33</a>] that is only employed in key generation. Although qTESLA performs polynomial multiplication by NTT, it is compatible with the Schoolbook algorithm. qTESLA uses cSHAKE [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0182">182</a>] to deterministically generate the random bits for driving seeds in key generation and the generation of a new polynomial for every key pair. In the signing step, qTESLA employs SHA-3 as the hash function and cSHAKE as the pseudo-random function. Contrary to the Ring-TESLA, qTESLA is secure against cache-side channel attacks by applying countermeasures introduced in Bindel et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0183">183</a>]; however, qTESLA is vulnerable to fault attacks [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0184">184</a>], similar to Ring-TESLA.</p> 
      <p>BLZZRD [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0050">50</a>], a lattice-based signature based on BLISS-B [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0120">120</a>], is implemented on an Intel Core-i7 Haswell processor with small signature size but with a costly signing step. The authors achieve optimal compression for discrete Gaussian distribution by using Binary Arithmetic Coding (<span style="font-family:monospace">BAC</span>) which leads to a more compact signature compared to the advanced Huffman-based signature compressors. Further security improvement is gained by prohibiting leakage of information about the execution time and power consumption of the arithmetic operation by applying randomization, which makes the signature resistant to timing and power attacks. The masking property of Gaussian samples is achieved by randomizing and combining multiple numbers of sample vectors.</p> 
      <p> <span style="font-family:monospace">Dilithium</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0131">131</a>], a simple and efficient digital signature scheme resistant to lattice reduction attacks (with the same conservative security parameter as in Alkim et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>]), is adapted from designs [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0061">61</a>], [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0094">94</a>] that uses the Fiat-Shamir Abort Framework [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0110">110</a>], which is secure in random oracle model (no security proof in quantum random oracle model is presented). The authors implement <span style="font-family:monospace">Dilithium</span> and its variant <span style="font-family:monospace">Dilithium-G</span> on Intel Core-i7 4770k with comparable efficiency to BLISS. In [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0061">61</a>], <em>hints</em> are generated by the signer to help the verifier to verify the signature, to make the signature smaller; <span style="font-family:monospace">Dilithium</span> improves the hint-generation and halves the public key size with a less than 5% increase in signature size. The authors set <em>total size</em> = <em>signature size</em> + <em>public key size</em> as their size parameter. <span style="font-family:monospace">Dilithium</span> over a ring of <span class="inline-equation"><span class="tex">$Z_q[x]$</span></span>/[<span class="inline-equation"><span class="tex">$x^{n}+1$</span></span>] (<span class="inline-equation"><span class="tex">$n=256,q=2^{23}-2^{13}+1=8380417$</span></span>) has slightly bigger <em>total size</em> than BLISS (over a ring of <span class="inline-equation"><span class="tex">$Z_q[x]$</span></span>/[<span class="inline-equation"><span class="tex">$x^{1024}+1$</span></span>]) with the same security level. <span style="font-family:monospace">Dilithium</span> samples polynomial noises from the uniform distribution <span class="inline-equation"><span class="tex">$S_\eta$</span></span> in <span class="inline-equation"><span class="tex">$[-\eta ,+\eta ],$</span></span> where <span class="inline-equation"><span class="tex">$\eta$</span></span> is in the range of [3--7] for very highly secure to weakly secure schemes, respectively. However, <span style="font-family:monospace">Dilithium-G</span> extract noise from the Gaussian sampler, which results in better security but vulnerable to timing attacks. Rejection sampling is the same for both schemes; if individual coefficients of a signature are not within a certain range, the signing procedure must be restarted. <span style="font-family:monospace">Dilithium</span> employs standard NTT-based polynomial multiplication; however, in the vectorized version, Dilithium uses integer instructions instead of floating point vector instructions [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>].</p> 
      <p> <span style="font-family:monospace">Dilithium</span> has been submitted to the NIST PQC standardization call at three security levels (all use the same ring) including <em>medium</em>, <em>recommended,</em> and <em>very high</em> (NIST security categories 1, 2, and 3) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0132">132</a>]. Dilithium is tightly secure in the quantum random oracle model based on the <em>Module-LWE</em>, <em>Module-SIS,</em> and <em>SelfTargetMSIS</em> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0185">185</a>] problem (adapted from combined security of the <span class="inline-equation"><span class="tex">$MSIS$</span></span> problem and hash function <span class="inline-equation"><span class="tex">$H$</span></span>). The signature size of Dilithium is about 2<span class="inline-equation"><span class="tex">$\times$</span></span> bigger than that of BLISS ([<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0033">33</a>],[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0186">186</a>]) (the smallest schemes among lattice-based digital signatures) that uses a discrete Gaussian sampler, which Dilithium avoids. However, compared to the most efficient lattice-based digital signature schemes that avoid Gaussian samplers, Dilithium achieves a 2.5<span class="inline-equation"><span class="tex">$\times$</span></span> smaller public key size. Coole-Tukey and Gentleman-Sande butterflies are used in NTT and inverse NTT, respectively, to perform the polynomial multiplication in which Montgomery reduction is used after multiplication (to avoid reduction after addition and subtraction). A vectorized (AVX2 instruction set on the Intel Core i7-4770K) version of NTT gives a 4.5<span class="inline-equation"><span class="tex">$\times$</span></span> speed improvement over the (reference) integer NTT implementation, which is 2<span class="inline-equation"><span class="tex">$\times$</span></span> faster than floating point NTT [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>]. Dilithium uses SHAKE128 and SHAKE256 to drive the matrix (<span class="inline-equation"><span class="tex">$A \in R^{k \times l}_q$</span></span> in NTT domain) and vectors. Vectorization improves speedup of the matrix and vector expansion by sampling four coefficients simultaneously.</p> 
      <p>Fouque et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0123">123</a>] propose <span style="font-family:monospace">FALCON</span>, a family of compact lattice-based hash-and-sign digital signature schemes with quantum security of 103, 172 and 230 bits (NIST security categories 1, 3, and 5) with the primary goal of minimizing the <em>total size</em> = <em>signature size</em> + <em>public key size</em>. FALCON is the result of combining the GPV framework [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0093">93</a>], NTRU lattices [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0089">89</a>], and Fast Fourier sampling [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0187">187</a>]; provably secure NTRUSign is built by combining the GVP framework and NTRU lattices [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0188">188</a>]. Instantiating the GPV IBE over NTRU lattices is presented in Ducas et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0186">186</a>], which can be transformed to FALCON by employing Fast Fourier sampling in private key operations. NTRU lattices with the capability of message recovery (entirely from the signature) result in the compactness of FALCON. The verification step in FALCON is relatively fast and simple and can be performed by a hash function followed by NTT operations. FALCON uses double precision floating-point arithmetic in signing, which can be challenging to implement on devices without floating point units. Another downside of FALCON is its extensive use of discrete Gaussian sampling over integers, which is hard to protect against timing and side-channel attacks. FFT over complex numbers is used for private key operations, while public key operations and key generation are performed using NTT over <span class="inline-equation"><img src="https://dl.acm.org/cms/attachment/12d5cba5-e2f5-413a-ad87-3a44e1202428/csur5106-129-inline621.gif" class="img-responsive" alt="" longdesc="" /></span>. FALCON uses bimodal Gaussian as the sampler, ChaCha20 as the PRNG and SHAKE-256 as XOF for all the security levels. FALCON can be easily transformed into an IBE scheme [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0186">186</a>]. The authors only provide a performance evaluation of the reference implementation on an Intel Core i7-6567U CPU with 15% of the error margin due to not disabling the boosting feature of the processor. Falcon has the smallest <em>total size</em> among all the post-quantum digital signature schemes of the same security level.</p> 
      <p>Chen et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0074">74</a>] present <span style="font-family:monospace">pqNTRUSign</span>, a modular lattice-based hash-then-sign digital signature scheme (introduced in Hoffstein et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0189">189</a>]) at a post-quantum security of 149-bit (NIST security category 5). pqNTRUSign provides sampler agility as the user can choose the sampler based on the design goal, constant time uniform sampling for the security, and (bimodal) Gaussian sampling for the performance goals, respectively. The key generation is the same for both sets of parameters (Gaussian-1024 and Uniform-1024); other steps have different implementations for various parameter sets. The public key, forgery, and transcript security are provided by the NTRU assumption, LWE problem over NTRU lattices, and rejection sampler, respectively. Like <span style="font-family:monospace">NTRUEncrypt</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0075">75</a>], Box-Muller [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0073">73</a>] is employed to sample from the discrete Gaussian distribution. AVX optimization for polynomial multiplication is not included in pqNTRUSign; a naive NTT with the time complexity of <span class="inline-equation"><span class="tex">$O(N^2/2)$</span></span> is used.</p> 
     </section> 
    </section> 
    <section id="sec-45"> 
     <header> 
      <div class="title-info"> 
       <h3> <span class="section-number">3.3</span> Hardware Implementations of Lattice-Based Cryptographic Schemes</h3> 
      </div> 
     </header> 
     <p>Nejatollahi et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0146">146</a>] propose the first domain-specific accelerators for ideal lattice-based schemes with the case studies of BLISS-BI [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0120">120</a>] and NewHope [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>]. The authors present a quick design flow that performs exploration and the design of programmable accelerators that lead to, on average, 35% and 50% improvement in the latency and energy-delay product, respectively. The authors create a programmable accelerator for NTT that can be employed in any scheme, with any set of parameters, and that uses Gentleman-Sande butterfly; the <span style="font-family:monospace">Keccak-f[1600]</span> accelerator is suitable for any classical and post-quantum cryptographic scheme as the heart of the SHA3.</p> 
     <section id="sec-46"> 
      <p> <span class="section-number">3.3.1</span> <em>Public Key Encryption.</em> G&ouml;ttert et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0056">56</a>] propose the first hardware implementation of Ring-LWE-based PKE on the Xilinx Virtex-7 FPGA. Due to the large area occupation of the full Ring-LWE PKE scheme, only LWE-polynomial variants are chosen to be implemented. Proposed implementations are based on LP lattice-based encryption scheme [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0046">46</a>], which achieves 316x higher throughput compared to a software implementation. Using a fully parallel architecture (which makes the design remarkably spacious), high throughput is achieved by minimizing required clock cycles in computing the NTT. The primary optimization metric is performance, for which they show speedups for encryption and decryption schemes by factors of 200 and 70, respectively, in comparison to the software implementation with the same level of security.</p> 
      <p>P&ouml;ppelmann et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0079">79</a>] provide a flexible Ring-LWE encryption engine in which one core is used to perform the key generation, encryption, and decryption steps with the primary goal of optimizing throughput per unit of area. In addition, by applying optimizations, including different encoding technique and removing some LSBs of the ciphertext coefficients and encryption engine, it can be fit in the Xilinx Spartan-6 FPGA with a 3&times; slower encryption step. They employ a Gaussian sampler with relatively low precision by using the CDT sampling method that compares random probabilities with a cumulative distribution table. The proposed Gaussian sampler is fast (one sampler per cycle at 60 MHz), with the cost of numerous random bits (85) to produce a single random number. The Gaussian sampler is time-independent with the cost of an array of parallel comparators, one per each word of the table.</p> 
      <p>Roy et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0037">37</a>] implement a compact Ring-LWE crypto processor on Virtex 6 FPGA where they optimize NTT multiplication by reducing the fixed computation and pre-scaling overheads. The authors suggest combining the precomputation stage and NTT computation. NTT memory access is minimized by storing two coefficients in a single word, processing two pairs of coefficients together, and eliminating the idle cycles. Small LUTs are used in the Knuth-Yao discrete Gaussian sampler [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0085">85</a>], which leads to more a compact and faster sampler than in P&ouml;ppelmann and G&uuml;neysu [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0059">59</a>].</p> 
      <p>P&ouml;ppelmann and G&uuml;neysu [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0059">59</a>] implement the smallest lattice-based encryption engine on Spartan-6 and Virtex-5. Compared with the high-speed implementation of P&ouml;ppelmann and G&uuml;neysu [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0079">79</a>], this is one order of magnitude slower due to the nonapplicability of using NTT (using instead a DSP-enabled schoolbook polynomial multiplier). In addition, considerable area is saved by using a specific modulus, a power of 2, by which modular reduction is almost cost-free. Further area saving is achieved by using a Bernoulli distribution [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0033">33</a>] with small precomputed tables in order to optimize simple rejection sampling by eliminating computing of the <span class="inline-equation"><span class="tex">$exp()$</span></span> function.</p> 
      <p>Howe et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0031">31</a>] present the first and only hardware implementation of a lattice-based encryption engine based on the LWE problem over standard lattices on the lightweight Spartan-6 FPGA. The main concern is optimizing the area, while the scheme maintains the balance between area and performance by using a larger Gaussian sampler. The proposed encryption engine is smaller in comparison to the design of G&ouml;ttert et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0056">56</a>]; in addition, it can closely compete with the encryption scheme of P&ouml;ppelmann and G&uuml;neysu [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0079">79</a>]. To maximize performance, the authors use a larger Gaussian sampler, a Bernoulli sampler, which generates samples in parallel with no adverse effect on the critical path.</p> 
      <p>Reparaz et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0135">135</a>] implement a masked Ring-LWE scheme on a 32-bit ARM Cortex-M4F and Virtex-II FPGA which is Differential Power Analysis (DPA)-resistant. In order to be first-order side-channel attack resilient, a constant time masked decoder with high success probability is implemented. The entire computation is done in the masked domain by employing a dedicated masked decoder which imposes considerable time and area overhead compared with an unprotected design.</p> 
     </section> 
     <section id="sec-47"> 
      <p> <span class="section-number">3.3.2</span> <em>Digital Signature.</em> Howe et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0034">34</a>] provide an evaluation and a summary of practical instantiations of digital signature schemes based on lattice problems on different platforms. Evaluation metrics are the secret key, public key, and signature size. Additionally, they give a survey of various implementations of basic blocks including NTT and sampling. The authors evaluate Bernoulli, Ziggurat, Knuth-Yao, and cumulative distribution table (CDT) variants of the Gaussian sampler.</p> 
      <p>G&uuml;neysu et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0061">61</a>] implement an efficient lattice-based signature scheme (GLP signature) on a Xilinx Virtex 6 FPGA, which is the first practical lattice-based signature scheme that could resist transcript collision attacks. The authors remove the need for Gaussian noise sampling by using rejection sampling, which leads to hiding the secret key contained in each signature. Security of the proposed scheme is lower than standard lattice-based signatures due to building the hardness assumption based on the Decisional Compact Knapsack problem. Because of the regular structure of the Schoolbook algorithm, the authors achieve high speed and small size for the implementation of the polynomial multiplier. Compared with BLISS, the proposed signature is suboptimal in terms of signature size and security level.</p> 
      <p>P&ouml;ppelmann et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0060">60</a>] achieve a high-throughput hardware implementation of BLISS [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0033">33</a>] on Xilinx Spartan-6 FPGA. The authors improve and parallelize the column-wise Schoolbook multiplier presented in G&uuml;neysu et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0061">61</a>]. The authors employ an efficient CDT-based Gaussian sampler with large tables. To improve the performance of the CDT sampler, the authors deploy a decreasing number of comparisons by improving the binary search and reducing the size of precomputed large tables by using an optimized floating-point representation (adaptive mantissa size) with negligible effect on the performance. They provide enhanced CDT, which uses two smaller samples (Peikert convolution theorem [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0047">47</a>]). A standard CDT needs a table of at least <span class="inline-equation"><span class="tex">$\eta \times \tau \times \lambda =215.73 \times 13.4 \times 128=370 kb$</span></span> while enhanced CDT needs around a 23<span class="inline-equation"><span class="tex">$\times$</span></span> smaller table. The authors evaluate the performance and resource consumption of BLISS-I (<span class="inline-equation"><span class="tex">$n=512,q=12289$</span></span>) by employing the CDT and two parallel Bernoulli samplers and conclude that CDT consumes less FPGA resources than Bernoulli; in addition, enhanced CDT achieves 17.4 Million Operation per Seconds (<span style="font-family:monospace">MOPS</span>), which is <span class="inline-equation"><span class="tex">$2.3 \times$</span></span> more than that of the Bernoulli sampler. Based on the results, the performance of enhanced CDT is almost the same for <span style="font-family:monospace">BLISS-I</span> (<span class="inline-equation"><span class="tex">$\sigma =215$</span></span>), <span style="font-family:monospace">BLISS-III</span> (<span class="inline-equation"><span class="tex">$\sigma =250$</span></span>), and <span style="font-family:monospace">BLISS-IV</span> (<span class="inline-equation"><span class="tex">$\sigma =271$</span></span>).</p> 
      <p>G&uuml;neysu et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0144">144</a>] propose an optimized and flexible implementation of a lattice-based digital signature on Xilinx Spartan-6 and Virtex-6 FPGAs which has the same theoretical basis as G&uuml;neysu et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0061">61</a>] but with major improvements. Compared with G&uuml;neysu et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0061">61</a>], instead of the Schoolbook multiplier, authors employ a parallelized NTT for polynomial multiplications (the most time-consuming part of the digital signature), which leads to smaller and faster signing/ verification engines. They develop a flexible processing core with VHDL that could be configured as either a signing or/and verification engine which does not impose any overhead to provide flexibility. The signing step breaks into three separate blocks, including a lattice processing engine, random oracle, and sparse multiplication along with compression unit; these run in parallel. The digital signature processor is based on the lattice processor for the PKE scheme in P&ouml;ppelmann and G&uuml;neysu [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0079">79</a>].</p> 
     </section> 
     <section id="sec-48"> 
      <p> <span class="section-number">3.3.3</span> <em>Key Exchange.</em> Oder et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0071">71</a>] propose an area-optimized constant time implementation of <span style="font-family:monospace">NewHope-Simple</span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0062">62</a>] on Xilinx Artix-7 FPGA, with a decent performance level. With the same post-quantum security level as <span style="font-family:monospace">NewHope</span> (128-bit), server and client work with clock frequencies of 125 and 117 MHz, respectively. The authors design two separate modules for the client and server sides, which forces an embedded system to be only either a server or a client; this results in the lack of reusability as a disadvantage. For the sake of area optimization, 512 butterfly operations are performed serially, although they can be performed in parallel.</p> 
      <p>Kou et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0147">147</a>] provide a high-performance pipelined implementation of NewHope [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0040">40</a>] on Xilinx Artix-7 FPGA, which is 19.1<span class="inline-equation"><span class="tex">$\times$</span></span> (4 <span class="inline-equation"><span class="tex">$\times$</span></span>) faster (bigger) than the hardware implementation of the NewHope-Simple [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0071">71</a>]. In order to improve the performance, NTT operations are computed using four butterfly units; in addition, Longa-Naehrig modular reduction [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0039">39</a>] is used instead of Barrett reduction.</p> 
     </section> 
    </section> 
    <section id="sec-49"> 
     <header> 
      <div class="title-info"> 
       <h3> <span class="section-number">3.4</span> Hardware/Software Implementations of Lattice-Based Cryptographic Schemes</h3> 
      </div> 
     </header> 
     <p>Because of the probabilistic inherent feature of rejection sampling in the lattice-based schemes, the probability of generating an invalid signature exists that can be minimized by precomputation. Aysu et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0149">149</a>] divide the signature scheme in hash-based cryptographic signatures into two separate phases in order to minimize the energy and latency of signature generation. During the offline phase, input (message)-independent computations (e.g., key and random number generation) are performed, and results are stored in a memory buffer as coupons. Subsequently, the output is generated using the precomputed coupons and the input (message) during the online phase. Employing the same idea, Aysu et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0148">148</a>] implement a latency-optimized lattice-based signature with a hardware/software co-design technique. The main objective is to optimize latency, which is achieved by focusing on the signature generation step on the embedded device. On the other hand, the verification step is performed on high-performance platform servers. The signature generation scheme consists of two separate phases including offline and online phases, which are performed on the NIOS soft-core as software and on the Altera Cyclone-IV FPGA as hardware, respectively. Hardware is responsible for the low-latency hash function and polynomial multiplication; however, the software part computes and stores polynomials.</p> 
    </section> 
    <section id="sec-50"> 
     <header> 
      <div class="title-info"> 
       <h3> <span class="section-number">3.5</span> DSP Implementation</h3> 
      </div> 
     </header> 
     <p>In order to perform the Multiply-Accumulate (<span style="font-family:monospace">MAC</span>) operations of matrices in the encryption scheme, Howe et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0031">31</a>] utilize a dedicated DSP48A1 unit of the Spartan-6 FPGA to achieve an area-optimized hardware implementation of the standard LWE-based encryption engine. The primary goal is optimizing area, while the scheme maintains the balance between area and performance by using a larger Gaussian sampler.</p> 
    </section> 
   </section> 
   <section id="sec-51"> 
    <header> 
     <div class="title-info"> 
      <h2> <span class="section-number">4</span> CONCLUSION</h2> 
     </div> 
    </header> 
    <p>LBC algorithms and protocols promise to tackle the challenges posed by deployment across diverse computing platforms, as well as for diverse use cases within reasonable security, performance, and energy efficiency guarantees.</p> 
    <p>Numerous schemes and implementations to tackle different tradeoffs, such as memory footprint, security, performance, and energy efficiency, are mapped on a variety of platforms and apply to specific use cases. However, current designs are still deficient in addressing the need for agility, which is paramount to tackle the needs of emerging business models at the computing platform level. In addition, securing such platforms against physical attacks is a topic that needs to be researched.</p> 
    <p>In this article, we provided a review of LBC, some of the proposals for lattices in computer security, their implementations in software and hardware, and their applications to key exchange/encapsulation and digital signatures.</p> 
   </section> 
  </section> 
  <section class="back-matter"> 
   <section id="ref-001"> 
    <header> 
     <div class="title-info"> 
      <h2 class="page-brake-head">REFERENCES</h2> 
     </div> 
    </header> 
    <ul class="bibUl"> 
     <li id="Bib0001" label="[1]">Hamid Nejatollahi, Nikil Dutt, Sandip Ray, Francesco Regazzoni, Indranil Banerjee, and Rosario Cammarota. 2017. Software and hardware implementation of lattice-cased cryptography schemes. <em>University of California Irvine, CECS TR 17-04</em> (2017).</li> 
     <li id="Bib0002" label="[2]">Peter W. Shor. 1997. Polynomial-time algorithms for prime factorization and discrete logarithms on a quantum computer. <em>SIAM Journal of Computing</em> (1997).</li> 
     <li id="Bib0003" label="[3]">Gui-Lu Long. 2001. Grover algorithm with zero theoretical failure rate. <em>Physical Review A</em> (2001).</li> 
     <li id="Bib0004" label="[4]">Ali Ansarmohammadi, Saeed Shahinfar, and Hamid Nejatollahi. 2015. Fast and area efficient implementation for chaotic image encryption algorithms. In <em>CADS</em>.</li> 
     <li id="Bib0005" label="[5]">Ali Ansarmohammadi, Hamid Nejatollahi, and Ghasemi Mehdi. 2013. A low-cost implementation of AES accelerator using HW/SW co-design technique. In <em>CADS</em>.</li> 
     <li id="Bib0006" label="[6]">Oscar Garcia-Morchon, Ronald Rietman, Sahil Sharma, Ludo Tolhuizen, and Jose Luis Torre-Arce. 2015. DTLS-HIMMO: Achieving DTLS certificate security with symmetric key overhead. In <em>ESORICS</em>.</li> 
     <li id="Bib0007" label="[7]">Oded Regev. 2005. On lattices, learning with errors, random linear codes, and cryptography. (2005).</li> 
     <li id="Bib0008" label="[8]">Mikl&oacute;s Ajtai. 1996. Generating hard instances of lattice problems (extended abstract). In <em>STOC</em>.</li> 
     <li id="Bib0009" label="[9]">Daniele Micciancio and Oded Regev. 2009. <em>Lattice-based Cryptography</em>.</li> 
     <li id="Bib0010" label="[10]">Mikl&oacute;s Ajtai, Ravi Kumar, and Dandapani Sivakumar. 2001. A sieve algorithm for the shortest lattice vector problem. In <em>STOC</em>.</li> 
     <li id="Bib0011" label="[11]">Daniele Micciancio and Panagiotis Voulgaris. 2010. Faster exponential time algorithms for the shortest vector problem. In <em>SODA</em>.</li> 
     <li id="Bib0012" label="[12]">Divesh Aggarwal, Daniel Dadush, Oded Regev, and Noah Stephens-Davidowitz. 2015. Solving the shortest vector problem in 2N time using discrete Gaussian sampling: Extended abstract. In <em>STOC</em>.</li> 
     <li id="Bib0013" label="[13]">Daniele Micciancio. 2010. <em>Cryptographic Functions from Worst-Case Complexity Assumptions</em>.</li> 
     <li id="Bib0014" label="[14]">Damien Stehl&eacute;, Ron Steinfeld, Keisuke Tanaka, and Keita Xagawa. 2009. Efficient public key encryption based on ideal lattices. In <em>ASIACRYPT</em>.</li> 
     <li id="Bib0015" label="[15]">Zvika Brakerski, Adeline Langlois, Chris Peikert, Oded Regev, and Damien Stehl&eacute;. 2013. Classical hardness of learning with errors. In <em>STOC</em>.</li> 
     <li id="Bib0016" label="[16]">Benny Applebaum, et al. 2009. Fast cryptographic primitives and circular-secure encryption based on hard learning problems. In <em>CRYPTO</em>.</li> 
     <li id="Bib0017" label="[17]">Vadim Lyubashevsky, Chris Peikert, and Oded Regev. 2010. On ideal lattices and learning with errors over rings. In <em>EUROCRYPT’10</em>.</li> 
     <li id="Bib0018" label="[18]">Abhishek Banerjee, Chris Peikert, and Alon Rosen. 2012. Pseudorandom functions and lattices. In <em>Proceedings of the Annual International Conference on Theory and Applications of Cryptographic Techniques</em>.</li> 
     <li id="Bib0019" label="[19]">Adeline Langlois and Damien Stehl&eacute;. 2012. Worst-case to average-case reductions for module lattices. Cryptology ePrint Archive. (2012).</li> 
     <li id="Bib0020" label="[20]">Hamid Nejatollahi, Nikil Dutt, and Rosario Cammarota. 2017. Trends, challenges and needs for lattice-based cryptography implementations: Special session. In <em>CODES</em>.</li> 
     <li id="Bib0021" label="[21]">Donald E. Knuth. 1997. <em>The Art of Computer Programming, Volume 2 (3rd Ed.): Seminumerical Algorithms</em>.</li> 
     <li id="Bib0022" label="[22]">Stephen Cook, et al. 1969. On the minimum computation time of functions. <em>Ph.D. Dissertation, Harvard University</em> (1969).</li> 
     <li id="Bib0023" label="[23]">Anatolii Karatsuba and Yu Ofman. 1963. Multiplication of many-digital numbers by automatic computers. In <em>USSR Academy of Sciences</em>.</li> 
     <li id="Bib0024" label="[24]">Arnold Sch&ouml;nhage and Volker Strassen. 1971. Schnelle multiplikation Grosser Zahlen. <em>Computing</em> (1971).</li> 
     <li id="Bib0025" label="[25]">Martin F&uuml;rer. 2009. Faster integer multiplication. <em>SIAM Journal of Comput.</em> (2009).</li> 
     <li id="Bib0026" label="[26]">Henri Nussbaumer. 1980. Fast polynomial transform algorithms for digital convolution. <em>TASSP</em> (1980).</li> 
     <li id="Bib0027" label="[27]">James W. Cooley, et al. 1965. An algorithm for the machine calculation of complex journal = Mathematics of Computation, fourier booktitle. (1965).</li> 
     <li id="Bib0028" label="[28]">W Morven Gentleman, et al. 1966. Fast fourier transforms: For fun and profit. In <em>AFIPS’66</em>.</li> 
     <li id="Bib0029" label="[29]">Peter L Montgomery. 1985. Modular multiplication without trial division. <em>Mathematics of Computation</em> (1985).</li> 
     <li id="Bib0030" label="[30]">Paul Barrett. 1986. Implementing the Rivest Shamir and Adleman public key encryption algorithm on a standard digital signal processor. In <em>CRYPTO</em>.</li> 
     <li id="Bib0031" label="[31]">J. Howe, C. Moore, M. O'Neill, F. Regazzoni, T. G&uuml;neysu, and K. Beeden. 2016. Lattice-based encryption over standard lattices in hardware. In <em>DAC</em>.</li> 
     <li id="Bib0032" label="[32]">Joppe Bos, Craig Costello, L&eacute;o Ducas, Ilya Mironov, Michael Naehrig, Valeria Nikolaenko, Ananth Raghunathan, and Douglas Stebila. 2016. Frodo: Take off the ring! Practical, quantum-secure key exchange from LWE. In <em>CCS</em>.</li> 
     <li id="Bib0033" label="[33]">L&eacute;o Ducas, Alain Durmus, Tancr&egrave;de Lepoint, and Vadim Lyubashevsky. 2013. Lattice signatures and bimodal Gaussians. In <em>CRYPTO</em>.</li> 
     <li id="Bib0034" label="[34]">James Howe, Thomas P&ouml;ppelmann, M&aacute;ire O'Neill, Elizabeth O'Sullivan, and Tim G&uuml;neysu. 2015. Practical lattice-based digital signature schemes. <em>TECS</em> (2015).</li> 
     <li id="Bib0035" label="[35]">Tobias Oder, Tim G&uuml;neysu, Felipe Valencia, Ayesha Khalid, Maire O'Neill, and Francesco Regazzoni. 2016. Lattice-based cryptography: From reconfigurable hardware to ASIC. In <em>ISIC</em>.</li> 
     <li id="Bib0036" label="[36]">Franz Winkler. 1996. Polynomial algorithms in computer algebra. In <em>TMSC</em>.</li> 
     <li id="Bib0037" label="[37]">Sujoy Sinha Roy, Frederik Vercauteren, Nele Mentens, Donald Donglong Chen, and Ingrid Verbauwhede. 2014. Compact ring-LWE cryptoprocessor. In <em>CHES’14</em>.</li> 
     <li id="Bib0038" label="[38]">Thomas P&ouml;ppelmann, Tobias Oder, and Tim G&uuml;neysu. 2015. High-performance ideal lattice-based cryptography on 8-bit ATxmega microcontrollers. In <em>LATINCRYPT</em>.</li> 
     <li id="Bib0039" label="[39]">Patrick Longa and Michael Naehrig. 2016. Speeding up the number theoretic transform for faster ideal lattice-based cryptography. Cryptology ePrint Archive. (2016).</li> 
     <li id="Bib0040" label="[40]">Erdem Alkim, L&eacute;o Ducas, Thomas P&para;ppelmann, and Peter Schwabe. 2015. Post-quantum key exchange: -A new hope. Cryptology ePrint Archive. (2015).</li> 
     <li id="Bib0041" label="[41]">Joppe Bos, L&eacute;o Ducas, Eike Kiltz, Tancr&egrave;de Lepoint, Vadim Lyubashevsky, John M. Schanck, Peter Schwabe, and Damien Stehl&eacute;. 2017. CRYSTALS: Kyber: A CCA-secure Module-Lattice-Based KEM. Cryptology ePrint Archive. (2017).</li> 
     <li id="Bib0042" label="[42]">Jean Pierre David, et al. 2007. Hardware complexity of modular multiplication and exponentiation. <em>TC</em> (2007).</li> 
     <li id="Bib0043" label="[43]">Donald Donglong Chen, Gavin Xiaoxu Yao, Ray C. C. Cheung, Derek Pao, and Cetin Kaya Ko&ccedil;. 2016. Parameter space for the architecture of FFT-based montgomery modular multiplication. <em>TC</em> (2016).</li> 
     <li id="Bib0044" label="[44]">Ciara Rafferty, Maire O'Neill, and Neil Hanley. 2017. Evaluation of large integer multiplication methods on hardware. <em>TC</em> (2017).</li> 
     <li id="Bib0045" label="[45]">Paul G. Comba. 1990. Exponentiation cryptosystems on the IBM PC. <em>IBM Systems Journal</em> (1990).</li> 
     <li id="Bib0046" label="[46]">Richard Lindner and Chris Peikert. 2011. Better key sizes (and attacks) for LWE-based encryption. In <em>CT-RSA’11</em>.</li> 
     <li id="Bib0047" label="[47]">Chris Peikert. 2010. An efficient and parallel Gaussian sampler for lattices. In <em>CRYPTO’10</em>.</li> 
     <li id="Bib0048" label="[48]">Shi Bai, Adeline Langlois, Tancr&egrave;de Lepoint, Damien Stehl&eacute;, and Ron Steinfeld. 2015. Improved security proofs in lattice-based cryptography: Using the R&eacute;nyi divergence rather than the statistical distance. In <em>ASIACRYPT</em>.</li> 
     <li id="Bib0049" label="[49]">Markku-Juhani O. Saarinen. 2015. Gaussian sampling precision in lattice cryptography. Cryptology ePrint Archive. (2015).</li> 
     <li id="Bib0050" label="[50]">Markku-Juhani O. Saarinen. 2017. Arithmetic coding and blinding countermeasures for lattice signatures. <em>Journal of Cryptographic Engineering</em> (2017).</li> 
     <li id="Bib0051" label="[51]">Paulo S. L. M. Barreto, Patrick Longa, Michael Naehrig, Jefferson E. Ricardini, and Gustavo Zanon. 2016. Sharper Ring-LWE signatures. Cryptology ePrint Archive. (2016).</li> 
     <li id="Bib0052" label="[52]">J. Howe, A. Khalid, C. Rafferty, F. Regazzoni, and M. O'Neill. 2016. On practical discrete Gaussian samplers for lattice-based cryptography. <em>TC</em> (2016).</li> 
     <li id="Bib0053" label="[53]">Daniele Micciancio and Michael Walter. 2017. Gaussian sampling over the integers: Efficient, generic, constant-time. Cryptology ePrint Archive. (2017).</li> 
     <li id="Bib0054" label="[54]">J&aacute;nos Foll&aacute;th. 2014. Gaussian sampling in lattice based cryptography. <em>Tatra Mountains Mathematical Publications</em> (2014).</li> 
     <li id="Bib0055" label="[55]">John Von Neumann. 1951. Various techniques used in connection with random digits. <em>National Bureau of Standards Applied Mathematics booktitle</em> (1951).</li> 
     <li id="Bib0056" label="[56]">Norman G&ouml;ttert et al. 2012. On the design of hardware building blocks for modern lattice-based encryption schemes. In <em>CHES</em>.</li> 
     <li id="Bib0057" label="[57]">L&eacute;o Ducas and Phong Q. Nguyen. 2012. Faster Gaussian lattice sampling using lazy floating-point arithmetic. In <em>ASIACRYPT</em>.</li> 
     <li id="Bib0058" label="[58]">Thomas P&ouml;ppelmann. 2016. <em>Efficient Implementation of Ideal Lattice-Based Cryptography</em>. Ruhr-Universit&auml;t Bochum.</li> 
     <li id="Bib0059" label="[59]">Thomas P&ouml;ppelmann and Tim G&uuml;neysu. 2014. Area optimization of lightweight lattice-based encryption on reconfigurable hardware. In <em>ISCAS</em>.</li> 
     <li id="Bib0060" label="[60]">Thomas P&ouml;ppelmann, L&eacute;o Ducas, and Tim G&uuml;neysu. 2014. Enhanced lattice-based signatures on reconfigurable hardware. In <em>CHES</em>.</li> 
     <li id="Bib0061" label="[61]">Tim G&uuml;neysu, et al. 2012. Practical lattice-based cryptography: A signature scheme for embedded systems. In <em>CHES</em>.</li> 
     <li id="Bib0062" label="[62]">Erdem Alkim, L&eacute;o Ducas, Thomas Poppelmann, and Peter Schwabe. 2016. NewHope without reconciliation. Cryptology ePrint Archive. (2016).</li> 
     <li id="Bib0063" label="[63]">Erdem Alkim, Philipp Jakubeit, and Peter Schwabe. 2016. NewHope on ARM cortex-M. In <em>SPACE</em>.</li> 
     <li id="Bib0064" label="[64]">Silvan Streit and Fabrizio De Santis. 2017. Post-quantum key exchange on ARMv8-A: A New Hope for NEON made simple. Cryptology ePrint Archive. (2017).</li> 
     <li id="Bib0065" label="[65]">Thomas Poppelmann, Erdem Alkim, Roberto Avanzi, Joppe Bos, L&eacute;o Ducas, Antonio de la Piedra, Peter Schwabe, and Douglas Stebila. 2017. <em>NewHope</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0066" label="[66]">Markku-Juhani O. Saarinen. 2017. <em>HILA5</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0067" label="[67]">Xianhui Lu, Yamin Liu, Dingding Jia, Haiyang Xue, Jingnan He, and Zhenfei Zhang. 2017. <em>LAC</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0068" label="[68]">Nigel P. Smart, Martin R. Albrecht, Yehuda Lindell, Emmanuela Orsini, Valery Osheter, Kenny Paterson, and Guy Peer. 2017. <em>LIMA</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0069" label="[69]">Roberto Avanzi, Joppe Bos, L&eacute;o Ducas, Eike Kiltz, Tancrede Lepoint, Vadim Lyubashevsky, John M. Schanck, Peter Schwabe, Gregor Seiler, and Damien Stehl&eacute;. 2017. <em>CRYSTALS-KYBER</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0070" label="[70]">Ron Steinfeld, Amin Sakzad, and Raymond K. Zhao. 2017. <em>Titanium</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology. Available at <a class="link-inline force-break" href="https://csrc.nist.gov/projects/post-quantum-cryptography/round-1-submissions">https://csrc.nist.gov/projects/post-quantum-cryptography/round-1-submissions</a>.</li> 
     <li id="Bib0071" label="[71]">Oder Tobias and G&uuml;neysu Tim. 2017. Implementing the NewHope-simple key exchange on low-cost FPGAs. In <em>LATINCRYPT</em>.</li> 
     <li id="Bib0072" label="[72]">George Marsaglia, Wai Wan Tsang, et al. 2000. The Ziggurat method for generating random variables. <em>Journal of Statistical Software</em> (2000).</li> 
     <li id="Bib0073" label="[73]">George E. P. Box, Mervin E. Muller, et al. 1958. A note on the generation of random normal deviates. <em>The Annals of Mathematical Statistics</em> (1958).</li> 
     <li id="Bib0074" label="[74]">Cong Chen, Jeffrey Hoffstein, William Whyte, and Zhenfei Zhang. 2017. <em>pqNTRUSign: A Modular Lattice Signature Scheme</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0075" label="[75]">Zhenfei Zhang, Cong Chen, Jeffrey Hoffstein, and William Whyte. 2017. <em>NTRUEncrypt</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0076" label="[76]">Johannes Buchmann, Daniel Cabarcas, Florian G&ouml;pfert, Andreas H&uuml;lsing, and Patrick Weiden. 2013. Discrete Ziggurat: A time-memory trade-off for sampling from a Gaussian distribution over the integers. In <em>SAC</em>.</li> 
     <li id="Bib0077" label="[77]">David B. Thomas, Wayne Luk, Philip H. W. Leong, and John D. Villasenor. 2007. Gaussian random number generators. <em>ACM CSUR</em> (2007).</li> 
     <li id="Bib0078" label="[78]">Thomas P&ouml;ppelmann and Tim G&uuml;neysu. 2012. Towards efficient arithmetic for lattice-based cryptography on reconfigurable hardware. In <em>LATINCRYPT</em>.</li> 
     <li id="Bib0079" label="[79]">Thomas P&ouml;ppelmann and Tim G&uuml;neysu. 2013. Towards practical lattice-based public-key encryption on reconfigurable hardware. In <em>SAC</em>.</li> 
     <li id="Bib0080" label="[80]">Chaohui Du and Guoqiang Bai. 2015. Towards efficient discrete Gaussian sampling for lattice-based cryptography. In <em>FPL</em>.</li> 
     <li id="Bib0081" label="[81]">C. Du and G. Ba. 2016. High-performance software implementation of discrete Gaussian sampling for lattice-based cryptography. In <em>ITNEACC</em>.</li> 
     <li id="Bib0082" label="[82]">A. Khalid, J. Howe, C. Rafferty, and M. O'Neill. 2016. Time-independent discrete Gaussian sampling for post-quantum cryptography. In <em>FPT</em>.</li> 
     <li id="Bib0083" label="[83]">Donald E. Knuth and Andrew C. Yao. 1976. The complexity of nonuniform random number generation. <em>Algorithms and Complexity: New Directions and Recent Results</em> (1976).</li> 
     <li id="Bib0084" label="[84]">Ruan de Clercq, Sujoy Sinha Roy, Frederik Vercauteren, and Ingrid Verbauwhede. 2015. Efficient software implementation of ring-LWE encryption. In <em>DATE</em>.</li> 
     <li id="Bib0085" label="[85]">Sujoy Sinha Roy, Frederik Vercauteren, and Ingrid Verbauwhede. 2013. High precision discrete Gaussian sampling on FPGAs. In <em>SAC</em>.</li> 
     <li id="Bib0086" label="[86]">Sujoy Sinha Roy, Oscar Reparaz, Frederik Vercauteren, and Ingrid Verbauwhede. 2014. Compact and side channel secure discrete Gaussian sampling. Cryptology ePrint Archive. (2014).</li> 
     <li id="Bib0087" label="[87]">Daniele Micciancio and Oded Regev. 2007. Worst-case to average-case reductions based on Gaussian measures. <em>SIAM Journal of Computing</em> (2007).</li> 
     <li id="Bib0088" label="[88]">Chris Peikert, Vinod Vaikuntanathan, and Brent Waters. 2008. A framework for efficient and composable oblivious transfer. In <em>CRYPTO</em>.</li> 
     <li id="Bib0089" label="[89]">Jeffrey Hoffstein, et al. 1998. NTRU: A ring-based public key cryptosystem. In <em>ANTS-III</em>.</li> 
     <li id="Bib0090" label="[90]">Damien Stehl&eacute;, et al. 2011. Making NTRU as secure as worst-case problems over ideal lattices. In <em>EUROCRYPT</em>.</li> 
     <li id="Bib0091" label="[91]">Mike Hamburg. 2017. <em>Three Bears</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0092" label="[92]">Miruna Rosca, Amin Sakzad, Ron Steinfeld, and Damien Stehl&eacute;. 2017. Middle-product learning with errors. Cryptology ePrint Archive. (2017).</li> 
     <li id="Bib0093" label="[93]">Craig Gentry, Chris Peikert, and Vinod Vaikuntanathan. 2008. Trapdoors for hard lattices and new cryptographic constructions. In <em>STOC</em>.</li> 
     <li id="Bib0094" label="[94]">Shi Bai and Steven D. Galbraith. 2014. An improved compression technique for signatures based on learning with errors. In <em>CT-RSA</em>.</li> 
     <li id="Bib0095" label="[95]"> 1997. Public-key cryptosystems from lattice reduction problems. In <em>CRYPTO</em>.</li> 
     <li id="Bib0096" label="[96]">Jeffrey Hoffstein, et al. 2003. NTRUSign: Digital signatures using the NTRU lattice. In <em>CT-RSA</em>.</li> 
     <li id="Bib0097" label="[97]">Jintai Ding, Xiang Xie, and Xiaodong Lin. 2012. A simple provably secure key exchange scheme based on the learning with errors problem. Cryptology ePrint Archive, (2012).</li> 
     <li id="Bib0098" label="[98]">Joppe W. Bos, Craig Costello, Michael Naehrig, and Douglas Stebila. 2015. Post-quantum key exchange for the TLS protocol from the ring learning with errors problem. In <em>SP</em>.</li> 
     <li id="Bib0099" label="[99]">Eiichiro Fujisaki and Tatsuaki Okamoto. 1999. How to enhance the security of public-key encryption at minimum cost. In <em>PKC</em>.</li> 
     <li id="Bib0100" label="[100]">Dennis Hofheinz, Kathrin H&Atilde;&para;velmanns, and Eike Kiltz. 2017. A modular analysis of the Fujisaki-Okamoto transformation. Cryptology ePrint Archive. (2017).</li> 
     <li id="Bib0101" label="[101]"> 2017. NIST: National institute for standards and technology. Postquantum Crypto Project. (2017).</li> 
     <li id="Bib0102" label="[102]">Le Trieu Phong, Takuya Hayashi, Yoshinori Aono, and Shiho Moriai. 2017. <em>LOTUS</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0103" label="[103]">Jung Hee Cheon, Duhyeong Kim, Joohee Lee, and Yongsoo Song. 2016. Lizard: Cut off the tail! Practical post-quantum public-key encryption from LWE and LWR. Cryptology ePrint Archive. (2016).</li> 
     <li id="Bib0104" label="[104]">Jung Hee Cheon, Sangjoon Park, Joohee Lee, Duhyeong Kim, Yongsoo Song, Seungwan Hong, Dongwoo Kim, Jinsu Kim, Seong-Min Hong, Aaram Yun, Jeongsu Kim, Haeryong Park, Eunyoung Choi, Kimoon kim, Jun-Sub Kim, and Jieun Lee. 2017. <em>Lizard</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0105" label="[105]">Jeff Hoffstein, Jill Pipher, John M. Schanck, Joseph H. Silverman, William Whyte, and Zhenfei Zhang. 2017. Choosing parameters for NTRUEncrypt. In <em>CT-RSA</em>.</li> 
     <li id="Bib0106" label="[106]">Minhye Seo, Jong Hwan Park, Dong Hoon Lee, Suhri Kim, and Seung-Joon Lee. 2017. <em>EMBLEM and R.EMBLEM</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0107" label="[107]">Michael Naehrig, Erdem Alkim, Joppe Bos, L&eacute;o Ducas, Karen Easterbrook, Brian LaMacchia, Patrick Longa, Ilya Mironov, Valeria Nikolaenko, Christopher Peikert, Ananth Raghunathan, and Douglas Stebila. 2017. <em>FrodoKEM</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0108" label="[108]">Thomas Plantard. 2017. <em>Odd Manhattan</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0109" label="[109]">Oscar Garcia-Morchon, Zhenfei Zhang, Sauvik Bhattacharya, Ronald Rietman, Ludo Tolhuizen, and Jose-Luis Torre-Arce. 2017. <em>Round2</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0110" label="[110]">Vadim Lyubashevsky. 2009. Fiat-Shamir with aborts: Applications to lattice and factoring-based signatures. In <em>ASIACRYPT</em>.</li> 
     <li id="Bib0111" label="[111]">Erdem Alkim, Nina Bindel, Johannes Buchmann, &Atilde;zugijr Dagdelen, Edward Eaton, Gus Gutoski, Juliane Krd'mer, and Filip Pawlega. 2015. Revisiting TESLA in the quantum random oracle model. Cryptology ePrint Archive. (2015).</li> 
     <li id="Bib0112" label="[112]">Sauvik Bhattacharya, Oscar Garcia-Morchon, Ronald Rietman, and Ludo Tolhuizen. 2017. spKEX: An optimized lattice-based key exchange. Cryptology ePrint Archive. (2017).</li> 
     <li id="Bib0113" label="[113]">Zhengzhong Jin and Yunlei Zhao. 2017. Optimal key consensus in presence of noise. Cryptology ePrint Archive. (2017).</li> 
     <li id="Bib0114" label="[114]">Yunlei Zhao, Zhengzhong jin, Boru Gong, and Guangye Sui. 2017. <em>A Modular and Systematic Approach to Key Establishment and Public-Key Encryption Based on LWE and Its Variants</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0115" label="[115]">Daniel J. Bernstein, Chitchanok Chuengsatiansup, Tanja Lange, and Christine van Vredendaal. 2016. NTRU Prime: Reducing attack surface at low cost. Cryptology ePrint Archive. (2016).</li> 
     <li id="Bib0116" label="[116]">Markku-Juhani Olavi Saarinen. 2017. Ring-LWE ciphertext compression and error correction: Tools for lightweight post-quantum cryptography. In <em>IoTPTS</em>.</li> 
     <li id="Bib0117" label="[117]">Markku-Juhani O. Saarinen. 2017. HILA5: On reliability, reconciliation, and error correction for Ring-LWE encryption. Cryptology ePrint Archive. (2017).</li> 
     <li id="Bib0118" label="[118]">Vadim Lyubashevsky. 2012. Lattice signatures without trapdoors. In <em>EUROCRYPT</em>.</li> 
     <li id="Bib0119" label="[119]">Rachid El Bansarkhani and Johannes Buchmann. 2013. Improvement and efficient implementation of a lattice-based signature scheme. In <em>SAC</em>.</li> 
     <li id="Bib0120" label="[120]">L&eacute;o Ducas. 2014. Accelerating Bliss: The geometry of ternary polynomials. Cryptology ePrint Archive. (2014).</li> 
     <li id="Bib0121" label="[121]">Arjun Chopra. 2016. Improved parameters for the Ring-TESLA digital signature scheme. Cryptology ePrint Archive. (2016).</li> 
     <li id="Bib0122" label="[122]">Arjun Chopra. 2017. GLYPH: A new instantiation of the GLP digital signature scheme. Cryptology ePrint Archive. (2017).</li> 
     <li id="Bib0123" label="[123]">Pierre-Alain Fouque et al. 2017. <em>FALCON: Fast-Fourier Lattice-based Compact Signatures over NTRU</em>.  
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0124" label="[124]">Nina Bindel, Sedat Akleylek, Erdem Alkim, Paulo S. L. M. Barreto, Johannes Buchmann, Edward Eaton, Gus Gutoski, Juliane Kramer, Patrick Longa, Harun Polat, Jefferson E. Ricardini, and Gustavo Zanon. 2017. <em>qTESLA</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0125" label="[125]">Andreas H&uuml;lsing, Joost Rijneveld, John Schanck, and Peter Schwabe. 2017. High-speed key encapsulation from NTRU. In <em>CHES</em>.</li> 
     <li id="Bib0126" label="[126]">Jintai Ding, Tsuyoshi Takagi, Xinwei Gao, and Yuntao Wang. 2017. <em>Ding Key Exchange</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0127" label="[127]">Andreas H&uuml;lsing, Joost Rijneveld, John M. Schanck, and Peter Schwabe. 2017. <em>NTRU-HRSS-KEM</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0128" label="[128]">Daniel J. Bernstein, Chitchanok Chuengsatiansup, Tanja Lange, and Christine van Vredendaal. 2017. <em>NTRU Prime</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0129" label="[129]">Rachid El Bansarkhani. 2017. <em>KINDI</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0130" label="[130]">Jan-Pieter D'Anvers, Angshuman Karmakar, Sujoy Sinha Roy, and Frederik Vercauteren. 2017. <em>SABER: Mod-LWR Based KEM</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0131" label="[131]">L&eacute;o Ducas, Tancr&egrave;de Lepoint, Vadim Lyubashevsky, Peter Schwabe, Gregor Seiler, and Damien Stehl&eacute;. 2017. CRYSTALS – Dilithium: Digital signatures from module lattices. Cryptology ePrint Archive. (2017).</li> 
     <li id="Bib0132" label="[132]">L&eacute;o Ducas, Eike Kiltz, Tancr&egrave;de Lepoint, Vadim Lyubashevsky, Peter Schwabe, Gregor Seiler, and Damien Stehl&eacute;. 2017. <em>CRYSTALS-Dilithium</em>. 
      <trans-title>
       Technical Report
      </trans-title>. National Institute of Standards and Technology.</li> 
     <li id="Bib0133" label="[133]">&Ouml;zg&uuml;r Dagdelen, Rachid El Bansarkhani, Florian G&ouml;pfert, Tim G&uuml;neysu, Tobias Oder, Thomas P&ouml;ppelmann, Ana Helena S&aacute;nchez, and Peter Schwabe. 2014. High-speed signatures from standard lattices. In <em>LATINCRYPT</em>.</li> 
     <li id="Bib0134" label="[134]">Zhe Liu, Hwajeong Seo, Sujoy Sinha Roy, Johann Gro&szlig;sch&auml;dl, Howon Kim, and Ingrid Verbauwhede. 2015. Efficient Ring-LWE encryption on 8-bit AVR processors. (2015).</li> 
     <li id="Bib0135" label="[135]">Oscar Reparaz, Sujoy Sinha Roy, Ruan de Clercq, Frederik Vercauteren, and Ingrid Verbauwhede. 2016. Masking ring-LWE. <em>Journal of Cryptographic Engineering</em> (2016).</li> 
     <li id="Bib0136" label="[136]">Johannes Buchmann, Florian G&ouml;pfert, Tim G&uuml;neysu, Tobias Oder, and Thomas P&ouml;ppelmann. 2016. High-performance and lightweight lattice-based public-key encryption. In <em>IoTPTS</em>.</li> 
     <li id="Bib0137" label="[137]">Ye Yuan, Chen-Mou Cheng, Shinsaku Kiyomoto, Yutaka Miyake, and Tsuyoshi Takagi. 2016. Portable implementation of lattice-based cryptography using JavaScript. In <em>CANDAR</em>.</li> 
     <li id="Bib0138" label="[138]">Tim G&uuml;neysu, Tobias Oder, Thomas P&ouml;ppelmann, and Peter Schwabe. 2013. Software speed records for lattice-based signatures. In <em>PQCrypto</em>.</li> 
     <li id="Bib0139" label="[139]">Tobias Oder, Thomas P&ouml;ppelmann, and Tim G&uuml;neysu. 2014. Beyond ECDSA and RSA: Lattice-based digital signatures on constrained devices. In <em>DAC</em>.</li> 
     <li id="Bib0140" label="[140]">Ahmad Boorghany, Siavash Bayat Sarmadi, and Rasool Jalili. 2015. On constrained implementation of lattice-based cryptographic primitives and schemes on smart cards. (2015).</li> 
     <li id="Bib0141" label="[141]">Thomas Poppelmann, Tobias Oder, and Tim Gijneysu. 2015. High-performance ideal lattice-based cryptography on 8-bit ATxmega microcontrollers. Cryptology ePrint Archive. (2015).</li> 
     <li id="Bib0142" label="[142]">Sedat Akleylek, Nina Bindel, Johannes Buchmann, Juliane Kr&auml;mer, and Giorgia Azzurra Marson. 2016. An efficient lattice-based signature scheme with provably secure instantiation. In <em>AFRICACRYPT</em>.</li> 
     <li id="Bib0143" label="[143]">Shay Gueron and Fabian Schlieker. 2016. Speeding up R-LWE post-quantum key exchange. Cryptology ePrint Archive. (2016).</li> 
     <li id="Bib0144" label="[144]">Tim G&uuml;neysu, Vadim Lyubashevsky, and Thomas P&ouml;ppelmann. 2015. Lattice-based signatures: Optimization and implementation on reconfigurable hardware. (2015).</li> 
     <li id="Bib0145" label="[145]">J. Howe, C. Rafferty, A. Khalid, and M. O'Neill. 2017. Compact and provably secure lattice-based signatures in hardware. (2017).</li> 
     <li id="Bib0146" label="[146]">Hamid Nejatollahi, Nikil Dutt, Indranil Banerjee, and Rosario Cammarota. 2018. Domain-specific accelerators for ideal lattice-based public key protocols. Cryptology ePrint Archive, Report 2018/608. (2018).</li> 
     <li id="Bib0147" label="[147]">Po-Chun Kuo, Wen-Ding Li, Yu-Wei Chen, Yuan-Che Hsu, Bo-Yuan Peng, Chen-Mou Cheng, and Bo-Yin Yang. 2017. High performance post-quantum key exchange on FPGAs. (2017).</li> 
     <li id="Bib0148" label="[148]">Aydin Aysu, Bilgiday Yuce, and Patrick Schaumont. 2015. The future of real-time security: Latency-optimized lattice-based digital signatures. (2015).</li> 
     <li id="Bib0149" label="[149]">A. Aysu and P. Schaumont. 2016. Precomputation methods for hash-based signatures on energy-harvesting platforms. <em>TC</em> (2016).</li> 
     <li id="Bib0150" label="[150]">Jeffrey Hoffstein, Jill Pipher, William Whyte, and Zhenfei Zhang. 2017. A signature scheme from learning with truncation. Cryptology ePrint Archive. (2017).</li> 
     <li id="Bib0151" label="[151]">Nagarjun C. Dwarakanath and Steven D. Galbraith. 2014. Sampling from discrete Gaussians for lattice-based cryptography on a constrained device. <em>Applicable Algebra in Engineering, Communication and Computing</em> (2014).</li> 
     <li id="Bib0152" label="[152]">Shruti More and Raj Katti. 2015. Discrete Gaussian sampling for low-power devices. In <em>PACRIM</em>.</li> 
     <li id="Bib0153" label="[153]">Pavel Emeliyanenko. 2009. Efficient multiplication of polynomials on graphics hardware. In <em>APPT</em>.</li> 
     <li id="Bib0154" label="[154]">Victor Shoup. 2016. NTL: A library for doing number theory. (2016).</li> 
     <li id="Bib0155" label="[155]">Sedat Akleylek, &Ouml;zgur Dağdelen, and Zaliha Y&uuml;ce Tok. 2015. On the efficiency of polynomial multiplication for lattice-based cryptography on GPUs using CUDA. In <em>ICCISB</em>.</li> 
     <li id="Bib0156" label="[156]">Sedat Akleylek, Erdem Alkım, and Zaliha Y&uuml;ce Tok. 2016. Sparse polynomial multiplication for lattice-based cryptography with small complexity. <em>The Journal of Supercomputing</em> (2016).</li> 
     <li id="Bib0157" label="[157]">Carlos Aguilar-Melchor, Joris Barrier, Serge Guelton, Adrien Guinet, Marc-Olivier Killijian, and Tancr&egrave;de Lepoint. 2016. NFLlib: NTT-based fast lattice library. In <em>CT-RSA</em>.</li> 
     <li id="Bib0158" label="[158]">Patrick Longa and Michael Naehrig. 2016. Speeding up the number theoretic transform for faster ideal lattice-based cryptography. In <em>CANS</em>.</li> 
     <li id="Bib0159" label="[159]">Aydin Aysu, Cameron Patterson, and Patrick Schaumont. 2013. Low-cost and area-efficient FPGA implementations of lattice-based cryptography. In <em>HOST</em>.</li> 
     <li id="Bib0160" label="[160]">Donald Donglong Chen, Nele Mentens, Frederik Vercauteren, Sujoy Sinha Roy, Ray C. C. Cheung, Derek Pao, and Ingrid Verbauwhede. 2015. High-speed polynomial multiplication architecture for ring-LWE and SHE cryptosystems. <em>TCS</em> (2015).</li> 
     <li id="Bib0161" label="[161]">Chaohui Du and Guoqiang Bai. 2016. A family of scalable polynomial multiplier architectures for Ring-LWE based cryptosystems. (2016).</li> 
     <li id="Bib0162" label="[162]">Tam&aacute;s Gy&ouml;rfi, Octavian Cret, and Zal&aacute;n Borsos. 2013. Implementing modular FFTs in FPGAs – A basic block for lattice-based cryptography. In <em>DSD</em>.</li> 
     <li id="Bib0163" label="[163]">Chaohui Du and Guoqiang Bai. 2016. Towards efficient polynomial multiplication for lattice-based cryptography. In <em>ISCAS</em>.</li> 
     <li id="Bib0164" label="[164]">Chaohui Du and Guoqiang Bai. 2016. Efficient polynomial multiplier architecture for Ring-LWE based public key cryptosystems. In <em>ISCAS</em>.</li> 
     <li id="Bib0165" label="[165]">Chaohui Du, Guoqiang Bai, and Xingjun Wu. 2016. High-speed polynomial multiplier architecture for ring-LWE based public key cryptosystems. In <em>GLSVLSI</em>.</li> 
     <li id="Bib0166" label="[166]">Nick Howgrave-Graham et al. 2003. NAEP: Provable security in the presence of decryption failures. Cryptology ePrint Archive. (2003).</li> 
     <li id="Bib0167" label="[167]">Daniel J. Bernstein. 2008. New stream cipher designs. Chapter The Salsa20 Family of Stream Ciphers.</li> 
     <li id="Bib0168" label="[168]"> 2009. IEEE standard specification for public key cryptographic techniques based on hard problems over lattices. <em>IEEE Std 1363.1-2008</em> (2009).</li> 
     <li id="Bib0169" label="[169]">El Bansarkhani Rachid. 2017. LARA: A design concept for lattice-based encryption. Cryptology ePrint Archive. (2017).</li> 
     <li id="Bib0170" label="[170]">Chris Peikert. 2014. Lattice cryptography for the Internet. In <em>PQCrypto</em>.</li> 
     <li id="Bib0171" label="[171]">Scott Fluhrer. 2016. Cryptanalysis of Ring-LWE based key exchange with key share reuse. Cryptology ePrint Archive. (2016).</li> 
     <li id="Bib0172" label="[172]">Matt Braithwaite. 2016. Experimenting with post-quantum cryptography. (2016).</li> 
     <li id="Bib0173" label="[173]">Daniel J. Bernstein. 2008. ChaCha, a variant of Salsa20. In <em>SASC</em>.</li> 
     <li id="Bib0174" label="[174]">Morris J. Dworkin. 2015. <em>SHA-3 Standard: Permutation-based Hash and Extendable-output Functions</em>. 
      <trans-title>
       Technical Report
      </trans-title>.</li> 
     <li id="Bib0175" label="[175]">Douglas Stebila and Michele Mosca. 2016. Post-quantum key exchange for the Internet and the Open Quantum Safe Project. Cryptology ePrint Archive. (2016).</li> 
     <li id="Bib0176" label="[176]">Alexander W. Dent. 2003. A designer's guide to KEMs. In <em>Cryptography and Coding</em>, Kenneth G. Paterson (Ed.).</li> 
     <li id="Bib0177" label="[177]">Vadim Lyubashevsky and Daniele Micciancio. 2009. On bounded distance decoding, unique shortest vectors, and the minimum distance problem. In <em>CRYPTO</em>.</li> 
     <li id="Bib0178" label="[178]">Gu Chunsheng. 2017. Integer version of Ring-LWE and its applications. Cryptology ePrint Archive. (2017).</li> 
     <li id="Bib0179" label="[179]">Guido Bertoni, Joan Daemen, Michael Peeters, and Gilles Van Assche. 2013. Keccak. In <em>EUROCRYPT</em>.</li> 
     <li id="Bib0180" label="[180]">Ahmad Boorghany and Rasool Jalili. 2014. Implementation and comparison of lattice-based identification protocols on smart cards and microcontrollers. Cryptology ePrint Archive. (2014).</li> 
     <li id="Bib0181" label="[181]">Daniele Micciancio and Chris Peikert. 2012. Trapdoors for lattices: Simpler, tighter, faster, smaller. In <em>EUROCRYPT</em>.</li> 
     <li id="Bib0182" label="[182]">John Kelsey. 2016. SHA-3 derived functions: cSHAKE, KMAC, TupleHash, and ParallelHash. <em>NIST Special Publication</em> (2016).</li> 
     <li id="Bib0183" label="[183]">Nina Bindel, Johannes Buchmann, Juliane Kramer, Heiko Mantel, Johannes Schickel, and Alexandra Weber. 2017. Bounding the cache-side-channel leakage of lattice-based signature schemes using program semantics. Cryptology ePrint Archive. (2017).</li> 
     <li id="Bib0184" label="[184]">Nina Bindel, Johannes Buchmann, and Juliane Kramer. 2016. Lattice-based signature schemes and their sensitivity to fault attacks. (2016).</li> 
     <li id="Bib0185" label="[185]">Eike Kiltz, Vadim Lyubashevsky, and Christian Schaffner. 2017. A concrete treatment of Fiat-Shamir signatures in the quantum random-oracle model. Cryptology ePrint Archive. (2017).</li> 
     <li id="Bib0186" label="[186]">L&eacute;o Ducas, Vadim Lyubashevsky, and Thomas Prest. 2014. Efficient identity-based encryption over NTRU lattices. In <em>ASIACRYPT</em>.</li> 
     <li id="Bib0187" label="[187]">L&eacute;o Ducas and Thomas Prest. 2016. Fast Fourier orthogonalization. In <em>ISSAC</em>.</li> 
     <li id="Bib0188" label="[188]">Damien Stehl&eacute; and Ron Steinfeld. 2011. Making NTRU as secure as worst-case problems over ideal lattices. In <em>EUROCRYPT</em>.</li> 
     <li id="Bib0189" label="[189]">Jeff Hoffstein, Jill Pipher, John M. Schanck, Joseph H. Silverman, and William Whyte. 2014. Transcript secure signatures based on modular lattices. In <em>PQCrypto</em>.</li> 
    </ul> 
   </section> 
  </section> 
  <section class="footnote" id="fngroup001"> 
   <header> 
    <div class="title-info"> 
     <h2>Footnotes</h2> 
    </div> 
   </header> 
   <section class="fnGroup"> 
    <ul class="fn"> 
     <li id="fn18"> <a href="#foot-fn18"><sup>1</sup></a> <a class="link-inline force-break" href="http://spectrum.ieee.org/tech-talk/computing/software/rigetti-launches-fullstack-quantum-computing-service-and-quantum-ic-fab">http://spectrum.ieee.org/tech-talk/computing/software/rigetti-launches-fullstack-quantum-computing-service-and-quantum-ic-fab</a>.</li> 
     <li id="fn19"> <a href="#foot-fn19"><sup>2</sup></a> <a class="link-inline force-break" href="https://newatlas.com/ibm-next-quantum-processors/49590/">https://newatlas.com/ibm-next-quantum-processors/49590/</a>.</li> 
     <li id="fn20"> <a href="#foot-fn20"><sup>3</sup></a>Another method to sample from a continuous Gaussian is <strong>Box-Muller</strong> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0073">73</a>]. The Box-Muller method transforms two independent uniforms into two independent discrete Gaussian distributions. pqNTRUSign [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0074">74</a>] and NTRUEncrypt [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0075">75</a>] use a Box-Muller-based Gaussian sampler.</li> 
     <li id="fn21"> <a href="#foot-fn21"><sup>4</sup></a>Indistinguishability under chosen plaintext attack.</li> 
     <li id="fn22"> <a href="#foot-fn22"><sup>5</sup></a>Indistinguishability under chosen ciphertext attack.</li> 
    </ul> 
   </section> 
   <p>An extended version of this paper can be found in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#Bib0001">1</a>].</p> 
   <p>This work was supported in part with a gift from Qualcomm Technology Inc.</p> 
   <p>Authors’ addresses: H. Nejatollahi, University of California Irvine, Irvine, California, 92697-3435; email: <a href="mailto:hnejatol@uci.edu">hnejatol@uci.edu</a>; N. Dutt, University of California Irvine, Irvine, California, 92697-3435; email: <a href="mailto:dutt@ics.uci.edu">dutt@ics.uci.edu</a>; S. Ray, University of Florida; email: <a href="mailto:sandip@ece.ufl.edu">sandip@ece.ufl.edu</a>; F. Regazzoni, ALaRi; email: <a href="mailto:regazzoni@alari.ch">regazzoni@alari.ch</a>; I. Banerjee, Qualcomm Technologies Inc. San Diego, CA, 92121-1714; email: <a href="mailto:ibanerje@qti.qualcomm.com">ibanerje@qti.qualcomm.com</a>; R. Cammarota, Qualcomm Technologies Inc. San Diego, CA, 92121-1714; email: <a href="mailto:ro.c@qti.qualcomm.com">ro.c@qti.qualcomm.com</a>.</p> 
   <p>Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from <a href="mailto:permissions@acm.org">permissions@acm.org</a>.</p> 
  </section> 
  <div class="bibStrip"> 
   <p>&copy;2019 Association for Computing Machinery.<br />0360-0300/2019/01-ART129 $15.00<br />DOI: <a href="https://doi.org/10.1145/3292548">https://doi.org/10.1145/3292548</a> </p> 
  </div> 
  <div class="pubHistory"> 
   <p>Publication History: Received November 2017; revised October 2018; accepted November 2018</p> 
  </div>   
 <script defer src="https://static.cloudflareinsights.com/beacon.min.js/v652eace1692a40cfa3763df669d7439c1639079717194" integrity="sha512-Gi7xpJR8tSkrpF7aordPZQlW2DLtzUlZcumS8dMQjwDHEnw9I7ZLyiOj/6tZStRBGtGgN6ceN6cMH8z7etPGlw==" data-cf-beacon='{"rayId":"7184d1e6bea5638a","token":"b7f168b3cd354a55a4dd51b513830799","version":"2021.12.0","si":100}' crossorigin="anonymous"></script>
</body>
</html>